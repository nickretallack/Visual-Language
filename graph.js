// Generated by CoffeeScript 1.3.3
(function() {
  var module, transform_position,
    __slice = [].slice;

  module = angular.module('vislang');

  transform_position = function(position, editor_size) {
    return {
      x: position.y + editor_size.x / 2,
      y: position.x + editor_size.y / 2
    };
  };

  module.directive('nib', function() {
    return {
      template: "<div class=\"nib\"></div>",
      replace: true,
      require: '^subroutine',
      scope: {
        nib: 'accessor'
      },
      link: function(scope, element, attributes, controller) {
        var nib;
        nib = scope.nib();
        nib.view = $(element);
        element.bind('mousedown', function(event) {
          return scope.$apply(function() {
            return controller.click_nib(nib, event);
          });
        });
        return element.bind('mouseup', function(event) {
          return scope.$apply(function() {
            return controller.release_nib(nib, event);
          });
        });
      }
    };
  });

  module.directive('subroutine', function($location) {
    return {
      link: function(scope, element, attributes) {},
      controller: function($scope, $element, $attrs, interpreter) {
        var $$element, canvas, canvas_offset, draw, header_height, nib_center, nib_offset, resize_canvas, subroutine;
        $$element = $($element);
        subroutine = $scope.$eval($attrs.subroutine);
        $scope.dragging = [];
        $scope.drawing = null;
        $scope.evaluate_output = function(output) {
          return subroutine.run(output);
        };
        $scope.new_input = function() {
          var nib;
          nib = new interpreter.Output;
          subroutine.inputs.push(nib);
          return async(function() {
            return $('.subroutine-input:last input').focus();
          });
        };
        $scope.new_output = function() {
          var nib;
          nib = new interpreter.Input;
          subroutine.outputs.push(nib);
          return async(function() {
            return $('.subroutine-output:last input').focus();
          });
        };
        $scope.delete_input = function($index) {
          var nib;
          nib = subroutine.inputs.splice($index, 1)[0];
          return nib.delete_connections();
        };
        $scope.delete_output = function($index) {
          var nib;
          nib = subroutine.outputs.splice($index, 1)[0];
          return nib.delete_connections();
        };
        /* Node and nib interaction
        */

        $scope.position = function(node) {
          var position;
          position = transform_position(node.position, $scope.editor_size);
          return {
            left: position.x + 'px',
            top: position.y + 'px'
          };
        };
        $scope.click_node = function(node, $event) {
          $event.preventDefault();
          return $scope.dragging = [node];
        };
        $scope.edit_node = function(node, $event) {
          $event.preventDefault();
          if (!(node instanceof interpreter.Literal)) {
            return $location.path("/" + node.implementation.id);
          }
        };
        $scope.name_node = function(node) {
          return node.text || node.implementation.id.slice(0, 6);
        };
        this.click_nib = $scope.click_nib = function(nib, $event) {
          $event.preventDefault();
          $event.stopPropagation();
          return $scope.drawing = nib;
        };
        this.release_nib = $scope.release_nib = function(nib) {
          var from, to, _ref;
          if ($scope.drawing) {
            _ref = [nib, $scope.drawing], from = _ref[0], to = _ref[1];
            if (from !== to && !((from instanceof interpreter.Input && to instanceof interpreter.Input) || (from instanceof interpreter.Output && to instanceof interpreter.Output))) {
              return from.connect(to);
            }
          }
        };
        $element.bind('mouseup', function(event) {
          return $scope.$apply(function() {
            $scope.dragging = [];
            $scope.drawing = null;
            return draw();
          });
        });
        $scope.mouse_position = V(0, 0);
        $element.bind('mousemove', function(event) {
          return $scope.$apply(function() {
            var mouse_delta, new_mouse_position, node, _i, _len, _ref;
            new_mouse_position = V(event.clientX, event.clientY);
            mouse_delta = $scope.mouse_position.minus(new_mouse_position);
            $scope.mouse_position = new_mouse_position;
            _ref = $scope.dragging;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              node.position = node.position.plus(V(-mouse_delta.y, -mouse_delta.x));
            }
            return draw();
          });
        });
        /* Drawing the Connection Field
        */

        header_height = 40;
        nib_center = V(5, 5);
        canvas_offset = V(0, header_height);
        nib_offset = canvas_offset.minus(nib_center);
        canvas = $element.find('canvas')[0];
        this.draw = draw = function() {
          return async(function() {
            var c, connection, end_position, id, input_element, input_position, line_height, nib_position, output_element, output_position, _ref;
            if (subroutine) {
              line_height = 16;
              c = canvas.getContext('2d');
              c.clearRect.apply(c, [0, 0].concat(__slice.call($scope.editor_size.components())));
              _ref = subroutine.connections;
              for (id in _ref) {
                connection = _ref[id];
                input_element = connection.input.view;
                output_element = connection.output.view;
                if (input_element && output_element) {
                  input_position = V(input_element.offset()).subtract(nib_offset);
                  output_position = V(output_element.offset()).subtract(nib_offset);
                  c.beginPath();
                  c.moveTo.apply(c, input_position.components());
                  c.lineTo.apply(c, output_position.components());
                  c.stroke();
                }
              }
              if ($scope.drawing) {
                nib_position = V($scope.drawing.view.offset()).subtract(nib_offset);
                end_position = $scope.mouse_position.subtract(canvas_offset);
                c.beginPath();
                c.moveTo.apply(c, nib_position.components());
                c.lineTo.apply(c, end_position.components());
                return c.stroke();
              }
            }
          });
        };
        resize_canvas = function() {
          var _ref;
          $scope.editor_size = V($$element.width(), $$element.height());
          _ref = $scope.editor_size.components(), canvas.width = _ref[0], canvas.height = _ref[1];
          return draw();
        };
        $(window).on('resize', function() {
          return $scope.$apply(resize_canvas);
        });
        return resize_canvas();
      }
    };
  });

}).call(this);
