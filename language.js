// Generated by CoffeeScript 1.6.3
(function() {
  var module,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module = angular.module('vislang');

  module.factory('interpreter', function($q, $http, $timeout, $rootScope) {
    var BaseType, BoundLambda, Call, Code, CodeSyntaxError, CoffeeScript, Connection, Definition, Exit, Graph, Input, InputError, JSON, JavaScript, Lambda, Literal, Nib, Node, NotConnected, NotImplemented, Output, Runtime, RuntimeException, Subroutine, Symbol, Text, Thread, Type, UnboundLambdaException, UnknownNode, Value, all_definitions, clone_endpoint, definition_class_map, definition_classes, dissociate_exception, eval_expression, execute, find_nib_uses, find_value, ignore_if_disconnected, is_input, is_lambda_value, last, load_implementation, load_implementation_v2, load_state, loaded, make_child_scope, make_connection, make_index_map, make_scope, make_value, node_class_map, node_classes, resurrect_node, save_state, schema_version, sequencer_input_nib, sequencer_output_nib, source_data, source_data_deferred, start_saving, strongly_connected_components, tarjan, value_output_nib, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    schema_version = 2;
    eval_expression = function(expression) {
      return eval("(" + expression + ")");
    };
    make_index_map = function(objects, attribute) {
      var obj, result, _i, _len;
      result = {};
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        result[obj[attribute]] = obj;
      }
      return result;
    };
    clone_endpoint = function(endpoint) {
      return {
        node: endpoint.node,
        nib: endpoint.nib
      };
    };
    last = function(list) {
      return list[list.length - 1];
    };
    /* EXCEPTION TYPES*/

    RuntimeException = (function() {
      function RuntimeException(message) {
        this.message = message;
      }

      return RuntimeException;

    })();
    Exit = (function(_super) {
      __extends(Exit, _super);

      function Exit() {
        this.message = "Exit Signal";
      }

      return Exit;

    })(RuntimeException);
    InputError = (function(_super) {
      __extends(InputError, _super);

      function InputError() {
        this.message = "Cancelled execution due to lack of input";
      }

      return InputError;

    })(RuntimeException);
    NotConnected = (function(_super) {
      __extends(NotConnected, _super);

      function NotConnected(message) {
        this.message = message != null ? message : "Something in the program is disconnected";
      }

      return NotConnected;

    })(RuntimeException);
    NotImplemented = (function(_super) {
      __extends(NotImplemented, _super);

      function NotImplemented(name) {
        this.name = name;
        this.message = "JavaScript \"" + this.name + "\" is not implemented";
      }

      return NotImplemented;

    })(RuntimeException);
    CodeSyntaxError = (function(_super) {
      __extends(CodeSyntaxError, _super);

      function CodeSyntaxError(name, exception) {
        this.name = name;
        this.exception = exception;
        this.message = "" + exception + " in builtin \"" + this.name + "\": ";
      }

      return CodeSyntaxError;

    })(RuntimeException);
    /* Exception types that should never happen unless the IDE is borked*/

    UnboundLambdaException = (function(_super) {
      __extends(UnboundLambdaException, _super);

      function UnboundLambdaException() {
        _ref = UnboundLambdaException.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      return UnboundLambdaException;

    })(RuntimeException);
    /* RUNTIME*/

    Thread = (function() {
      function Thread(runtime, id) {
        this.runtime = runtime;
        this.id = id;
        this.traces = [];
        this.state = this.runtime.state;
        this.graphics_element = this.runtime.graphics_element;
      }

      Thread.prototype.trace = function(log) {
        return this.traces.push(log);
      };

      Thread.prototype.log = function(message) {
        return this.runtime.log(message, this.id);
      };

      Thread.prototype.addEventListener = function() {
        var _ref1;
        return (_ref1 = this.runtime).addEventListener.apply(_ref1, [this].concat(__slice.call(arguments)));
      };

      Thread.prototype.setInterval = function() {
        var _ref1;
        return (_ref1 = this.runtime).setInterval.apply(_ref1, [this].concat(__slice.call(arguments)));
      };

      return Thread;

    })();
    Runtime = (function() {
      function Runtime(_arg) {
        var _ref1;
        _ref1 = _arg != null ? _arg : {}, this.graphics_element = _ref1.graphics_element, this.definition = _ref1.definition;
        this.log_messages = [];
        this.event_handlers = [];
        this.timers = [];
        this.state = {};
        this.threads = [];
      }

      Runtime.prototype.cleanup = function() {
        var handler, timer, _i, _j, _len, _len1, _ref1, _ref2, _results;
        _ref1 = this.event_handlers;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          handler = _ref1[_i];
          handler.element.removeEventListener(handler.type, handler.handler);
        }
        _ref2 = this.timers;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          timer = _ref2[_j];
          _results.push(clearTimeout(timer));
        }
        return _results;
      };

      Runtime.prototype.setInterval = function(thread, handler, output_index, delay) {
        var handle, timer,
          _this = this;
        handle = function() {
          return $rootScope.$apply(function() {
            return handler.call([], output_index, thread);
          });
        };
        timer = setInterval(handle, delay);
        return this.timers.push(timer);
      };

      Runtime.prototype.addEventListener = function(thread, type, handler_subroutine, element, output_index) {
        var handler,
          _this = this;
        if (output_index == null) {
          output_index = 0;
        }
        handler = function(event) {
          return $rootScope.$apply(function() {
            return handler_subroutine.call([event], output_index, thread);
          });
        };
        element.addEventListener(type, handler);
        return this.event_handlers.push({
          element: element,
          handler: handler,
          type: type
        });
      };

      Runtime.prototype.log = function(message, id) {
        var formatted_message;
        if (id == null) {
          id = 0;
        }
        formatted_message = "Thread " + id + ": " + message;
        this.log_messages.unshift(formatted_message);
        return console.log(formatted_message);
      };

      Runtime.prototype.new_thread = function() {
        var thread;
        thread = new Thread(this, this.threads.length);
        this.threads.push(thread);
        return thread;
      };

      Runtime.prototype.run = function(nib) {
        var exception, thread,
          _this = this;
        thread = this.new_thread();
        this.scope = make_scope({
          runtime: thread,
          inputs: this.definition.user_inputs()
        });
        try {
          return $timeout(function() {
            return execute(runtime, function() {
              return _this.definition.invoke(_this.scope, nib);
            });
          });
        } catch (_error) {
          exception = _error;
          if (excepition instanceof InputError) {
            return runtime.log("Invalid JSON: " + exception.message);
          } else {
            throw exception;
          }
        }
      };

      return Runtime;

    })();
    /* DEFINITION TYPES*/

    BaseType = (function() {
      function BaseType() {}

      BaseType.prototype.toJSON = function() {
        return {
          type: this.constructor.name
        };
      };

      return BaseType;

    })();
    Definition = (function(_super) {
      __extends(Definition, _super);

      function Definition(_arg) {
        var _ref1;
        _ref1 = _arg != null ? _arg : {}, this.id = _ref1.id, this.text = _ref1.text;
        if (this.id == null) {
          this.id = UUID();
        }
        all_definitions[this.id] = this;
      }

      Definition.prototype.fromJSON = function() {
        return this;
      };

      Definition.prototype.initialize = function() {
        return this;
      };

      Definition.prototype.toJSON = function() {
        return _.extend(Definition.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          text: this.text
        });
      };

      Definition.prototype.find_nib = function(id) {
        var nib, _i, _len, _ref1;
        _ref1 = this.inputs.concat(this.outputs);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          nib = _ref1[_i];
          if (nib.id === id) {
            return nib;
          }
        }
      };

      Definition.prototype.get_call_sinks = function() {
        return this.inputs;
      };

      Definition.prototype.get_value_sinks = function() {
        return [];
      };

      Definition.prototype.find_uses = function() {
        var graph, id, _results;
        _results = [];
        for (id in all_definitions) {
          graph = all_definitions[id];
          if (graph instanceof Graph && graph.uses_definition(this)) {
            _results.push(graph);
          }
        }
        return _results;
      };

      return Definition;

    })(BaseType);
    make_scope = function(_arg) {
      var child_scope, inputs, parent_scope, runtime, _ref1;
      _ref1 = _arg != null ? _arg : {
        inputs: [],
        parent_scope: null
      }, runtime = _ref1.runtime, inputs = _ref1.inputs, parent_scope = _ref1.parent_scope;
      child_scope = {};
      return {
        runtime: runtime,
        inputs: inputs,
        output_values: {},
        nodes: child_scope,
        state: child_scope,
        parent_scope: parent_scope
      };
    };
    make_child_scope = function(parent_scope, _arg) {
      var inputs, scope;
      inputs = (_arg != null ? _arg : {
        inputs: []
      }).inputs;
      scope = make_scope({
        runtime: parent_scope.runtime,
        inputs: inputs,
        parent_scope: parent_scope
      });
      return scope;
    };
    Subroutine = (function(_super) {
      __extends(Subroutine, _super);

      function Subroutine(_arg) {
        var data, inputs, outputs, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
        _ref1 = _arg != null ? _arg : {}, inputs = _ref1.inputs, outputs = _ref1.outputs, this.stateful = _ref1.stateful;
        Subroutine.__super__.constructor.apply(this, arguments);
        this.inputs = [];
        this.outputs = [];
        _ref2 = inputs || [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          data = _ref2[_i];
          this.add_input(data);
        }
        _ref3 = outputs || [];
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          data = _ref3[_j];
          this.add_output(data);
        }
      }

      Subroutine.prototype.user_inputs = function() {
        var input, results;
        results = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = this.inputs;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            input = _ref1[_i];
            _results.push((function(input) {
              return _.memoize(function() {
                var exception, input_name, result;
                result = input.default_value ? input.default_value : (input_name = input.text ? "\"" + input.text + "\"" : "(nameless)", prompt("Provide a JSON value for input " + input.index + ": " + input_name));
                if (result === null) {
                  throw new Exit("cancelled execution");
                }
                try {
                  return window.JSON.parse(result);
                } catch (_error) {
                  exception = _error;
                  if (exception instanceof SyntaxError) {
                    throw new InputError(result);
                  } else {
                    throw exception;
                  }
                }
              });
            })(input));
          }
          return _results;
        }).call(this);
        results.push(function() {});
        return results;
      };

      Subroutine.prototype.call = function(inputs, output_index, runtime) {
        var input, nib, scope, wrapped_inputs, _fn, _i, _len;
        if (output_index == null) {
          output_index = 0;
        }
        nib = this.outputs[output_index];
        wrapped_inputs = [];
        _fn = function(input) {
          return wrapped_inputs.push(function() {
            return input;
          });
        };
        for (_i = 0, _len = inputs.length; _i < _len; _i++) {
          input = inputs[_i];
          _fn(input);
        }
        scope = make_scope({
          runtime: runtime,
          inputs: wrapped_inputs
        });
        return this.invoke(scope, nib);
      };

      Subroutine.prototype.delete_nib = function(nib, group) {
        var index, _i, _len, _ref1, _results;
        this[group] = _.without(this[group], nib);
        _ref1 = this[group];
        _results = [];
        for (index = _i = 0, _len = _ref1.length; _i < _len; index = ++_i) {
          nib = _ref1[index];
          _results.push(nib.index = index);
        }
        return _results;
        /*
        delete_index = @[group].indexOf nib
        @[group].splice delete_index, 1
        for index in [delete_index...@[group].length]
            @[group][index].index -= 1
        */

      };

      Subroutine.prototype.add_nib = function(group, the_class, data) {
        var nib;
        if (data == null) {
          data = {};
        }
        nib = new the_class(_.extend(data, {
          index: this[group].length
        }));
        this[group].push(nib);
        return nib;
      };

      Subroutine.prototype.delete_input = function(nib) {
        return this.delete_nib(nib, 'inputs');
      };

      Subroutine.prototype.delete_output = function(nib) {
        return this.delete_nib(nib, 'outputs');
      };

      Subroutine.prototype.add_input = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('inputs', Input, data);
      };

      Subroutine.prototype.add_output = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('outputs', Output, data);
      };

      Subroutine.prototype.toJSON = function() {
        return _.extend(Subroutine.__super__.toJSON.apply(this, arguments), {
          inputs: this.inputs,
          outputs: this.outputs,
          stateful: this.stateful
        });
      };

      Subroutine.prototype.get_node_sources = function() {
        return this.inputs;
      };

      Subroutine.prototype.get_node_sinks = function() {
        return this.outputs;
      };

      Subroutine.prototype.get_call_sinks = function() {
        return this.add_stateful_nib(sequencer_input_nib, this.inputs);
      };

      Subroutine.prototype.get_call_sources = function() {
        return this.add_stateful_nib(sequencer_output_nib, this.outputs);
      };

      Subroutine.prototype.add_stateful_nib = function(nib, nibs) {
        if (!this.stateful) {
          return nibs;
        } else {
          return nibs.concat([nib]);
        }
      };

      Subroutine.prototype.evaluate = function() {
        return this;
      };

      return Subroutine;

    })(Definition);
    Code = (function(_super) {
      __extends(Code, _super);

      function Code(_arg) {
        this.output_implementation = (_arg != null ? _arg : {}).output_implementation;
        Code.__super__.constructor.apply(this, arguments);
      }

      Code.prototype.toJSON = function() {
        return _.extend(Code.__super__.toJSON.apply(this, arguments), {
          output_implementation: this.output_implementation
        });
      };

      Code.prototype.invoke = function(scope, output_nib, node) {
        var exception, input_generators, meta, output_function, result, stateful_input;
        if (node == null) {
          node = {
            id: 0
          };
        }
        input_generators = scope.inputs;
        if (this.stateful) {
          stateful_input = last(input_generators);
          input_generators = input_generators.slice(0, -1);
          ignore_if_disconnected(stateful_input);
        }
        meta = {
          runtime: scope.runtime,
          output_index: output_nib.index,
          inputs: input_generators,
          state: scope.nodes,
          is_sequencer: output_nib === sequencer_output_nib
        };
        try {
          output_function = this.eval_code(this.output_implementation);
        } catch (_error) {
          exception = _error;
          if (exception instanceof SyntaxError || exception instanceof Error) {
            throw new CodeSyntaxError(this.text, exception);
          } else {
            throw exception;
          }
        }
        if (!output_function) {
          throw new NotImplemented(this.text);
        }
        try {
          result = output_function.apply(null, [meta].concat(__slice.call(input_generators)));
          if (!meta.is_sequencer) {
            return result;
          }
        } catch (_error) {
          exception = _error;
          if (exception instanceof TypeError) {
            throw new CodeSyntaxError(this.text, exception);
          } else {
            throw exception;
          }
        }
      };

      Code.prototype.get_content_id = function() {
        return {
          implementation: this.output_implementation,
          type: 'code',
          language: this.language,
          inputs: this.inputs.length,
          outputs: this.outputs.length
        };
      };

      return Code;

    })(Subroutine);
    CoffeeScript = (function(_super) {
      __extends(CoffeeScript, _super);

      function CoffeeScript() {
        _ref1 = CoffeeScript.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      CoffeeScript.prototype.eval_code = function(code) {
        if (code) {
          return eval(window.CoffeeScript.compile(code, {
            bare: true
          }));
        }
      };

      CoffeeScript.prototype.language = 'coffeescript';

      return CoffeeScript;

    })(Code);
    JavaScript = (function(_super) {
      __extends(JavaScript, _super);

      function JavaScript() {
        _ref2 = JavaScript.__super__.constructor.apply(this, arguments);
        return _ref2;
      }

      JavaScript.prototype.eval_code = eval_expression;

      JavaScript.prototype.language = 'javascript';

      return JavaScript;

    })(Code);
    Graph = (function(_super) {
      __extends(Graph, _super);

      function Graph() {
        Graph.__super__.constructor.apply(this, arguments);
        this.nodes = [];
        this.connections = [];
      }

      Graph.prototype.toJSON = function() {
        return _.extend(Graph.__super__.toJSON.apply(this, arguments), {
          nodes: this.nodes,
          connections: this.connections
        });
      };

      Graph.prototype.get_name = function() {
        return this.text;
      };

      /* RUNNING*/


      Graph.prototype.invoke = function(scope, output_nib) {
        return this.evaluate_connection(scope, this, output_nib);
      };

      Graph.prototype.evaluate_connection = function(scope, to_node, to_nib) {
        /* This helper will follow a connection and evaluate whatever it finds*/

        var connection, connection_text, internal, nib, node, result, _ref3;
        connection = this.find_connection('to', to_node, to_nib);
        if (!connection) {
          connection_text = to_node.implementation != null ? to_node.implementation.text : to_node.text;
          throw new NotConnected("Missing connection in \"" + this.text + "\" to node \"" + connection_text + "\".");
        }
        _ref3 = connection.from, node = _ref3.node, nib = _ref3.nib, internal = _ref3.internal;
        scope.runtime.trace({
          scope: scope,
          graph: this,
          connection: connection,
          state: 'visiting'
        });
        if (internal) {
          if (node === scope.lambda_node) {
            result = scope.lambda_value_generators[nib.index]();
          } else {
            throw new UnboundLambdaException("Node '" + (to_node.get_name()) + "' tried to receive input from Lambda '" + (node.get_name()) + "' from outside its scope.");
          }
        } else if (node instanceof Graph) {
          result = scope.inputs[nib.index]();
        } else {
          result = node.evaluate(scope, nib);
        }
        scope.runtime.trace({
          scope: scope,
          graph: this,
          connection: connection,
          state: 'evaluated',
          value: result
        });
        return result;
      };

      Graph.prototype.find_node = function(id) {
        var node, _i, _len, _ref3;
        _ref3 = this.nodes;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          node = _ref3[_i];
          if (node.id === id) {
            return node;
          }
        }
      };

      Graph.prototype.find_connection = function(direction, node, nib) {
        var connection, _i, _len, _ref3;
        if (!((node != null) && (nib != null))) {
          console.log("what");
          console.log("what");
        }
        /* Use this to determine how nodes are connected*/

        _ref3 = this.connections;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          connection = _ref3[_i];
          if (connection[direction].node.id === node.id && connection[direction].nib.id === nib.id) {
            return connection;
          }
        }
        return void 0;
      };

      Graph.prototype.delete_connections = function(direction, node, nib) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection[direction].node === node && connection[direction].nib === nib;
        });
      };

      Graph.prototype.delete_node_connections = function(node) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection.from.node === node || connection.to.node === node;
        });
      };

      Graph.prototype.delete_nodes = function(nodes) {
        this.connections = _.reject(this.connections, function(connection) {
          var _ref3, _ref4;
          return (_ref3 = connection.from.node, __indexOf.call(nodes, _ref3) >= 0) || (_ref4 = connection.to.node, __indexOf.call(nodes, _ref4) >= 0);
        });
        return this.nodes = _.without.apply(_, [this.nodes].concat(__slice.call(nodes)));
      };

      Graph.prototype["export"] = function() {
        var dependencies;
        dependencies = this.get_dependencies();
        dependencies.schema_version = schema_version;
        return dependencies;
      };

      Graph.prototype.delete_input = function(nib) {
        this.delete_connections('to', this, nib);
        return Graph.__super__.delete_input.call(this, nib);
      };

      Graph.prototype.delete_output = function(nib) {
        this.delete_connections('from', this, nib);
        return Graph.__super__.delete_output.call(this, nib);
      };

      Graph.prototype.remove_node = function(node) {
        return this.nodes = _.without(this.nodes, node);
      };

      Graph.prototype.add_node = function(node) {
        node.graph = this;
        return this.nodes.push(node);
      };

      Graph.prototype.remove_connection = function(connection) {
        return this.connections = _.without(this.connections, connection);
      };

      Graph.prototype.add_connection = function(connection) {
        return this.connections.push(connection);
      };

      Graph.prototype.uses_definition = function(definition) {
        var node, _i, _len, _ref3;
        _ref3 = this.nodes;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          node = _ref3[_i];
          if (node.implementation === definition) {
            return true;
          }
        }
      };

      Graph.prototype.definitions_used = function() {
        var definitions, implementation, node, _i, _len, _ref3;
        definitions = {};
        _ref3 = this.nodes;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          node = _ref3[_i];
          implementation = node.implementation;
          definitions[implementation.id] = implementation;
        }
        return definitions;
      };

      /* probably outdated
      get_dependencies: (dependencies={subroutines:{},builtins:{}}) ->
          # TODO: UPDATE
          dependencies.subroutines[@id] = @ if @id not of dependencies.subroutines
          for id, node of @nodes
              if node instanceof SubroutineApplication
                  child_dependencies = node.implementation.get_dependencies dependencies
                  _.extend dependencies.subroutines, child_dependencies.subroutines
                  _.extend dependencies.builtins, child_dependencies.builtins
              else if node instanceof BuiltinApplication
                  dependencies.builtins[@id] = node.implementation
          dependencies
      
      subroutines_referenced: ->
          # TODO: UPDATE
          # TODO: turn this into a cleanup function
          results = []
          for output in @outputs
              parent = output.get_connection()?.connection.output.parent
              if parent
                  results.push parent.id if parent.type is 'function'
                  resuts = results.concat parent.subroutines_referenced()
          return results
      
      build_adjacency_list: ->
          # clear prior data
          for id, node of @nodes
              node.adjacency_id = null
      
          adjacency_list = []
      
          # number and add self first
          adjacency_list.push
              node:@
              connections:[]
          @adjacency_id = 0
      
          # number all the connected nodes in a predictable way, and add them to the list
          input_queue = [].concat @outputs
          while input_queue.length > 0
              input = input_queue.shift()
              node = input.get_node()
              # NOTE: if node is a subroutine then we've reached ourselves again
              if node instanceof Node and node.adjacency_id is null
                  item_count = adjacency_list.push
                      node:node
                      connections:[]
                  node.adjacency_id = item_count - 1 # length is offset by 1 from index
                  input_queue = input_queue.concat node.inputs
      
          # record all the connections based on the consistent numbering scheme
          for item in adjacency_list
              nibs = if item.node instanceof Node then item.node.inputs else item.node.outputs
              for input, input_index in nibs
                  node = input.parent
                  item.connections[input_index] = node.adjacency_id
      
          adjacency_list
      */


      Graph.prototype.bust_node = function(busting_node) {
        var beginning_connection, busting_scope, connection, inbound_connections, inner_connection, inner_connections, internal_connections, middle_connection, new_node, nib, node, node_mapping, outbound_connections, outer_connection, outer_connections, through_connections, translate_endpoint, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref3, _ref4,
          _this = this;
        this.remove_node(busting_node);
        busting_scope = busting_node.implementation;
        node_mapping = {};
        _ref3 = busting_scope.nodes;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          node = _ref3[_i];
          new_node = node.clone(this);
          node_mapping[node.id] = new_node;
        }
        translate_endpoint = function(endpoint) {
          return {
            node: node_mapping[endpoint.node.id],
            nib: endpoint.nib
          };
        };
        internal_connections = _.filter(busting_scope.connections, function(connection) {
          return connection.from.node !== busting_scope && connection.to.node !== busting_scope;
        });
        for (_j = 0, _len1 = internal_connections.length; _j < _len1; _j++) {
          connection = internal_connections[_j];
          new Connection({
            graph: this,
            from: translate_endpoint(connection.from),
            to: translate_endpoint(connection.to)
          });
        }
        inbound_connections = _.filter(this.connections, function(connection) {
          return connection.to.node === busting_node;
        });
        through_connections = [];
        for (_k = 0, _len2 = inbound_connections.length; _k < _len2; _k++) {
          connection = inbound_connections[_k];
          this.remove_connection(connection);
          nib = connection.to.nib;
          inner_connections = _.filter(busting_scope.connections, function(inner_connection) {
            return inner_connection.from.nib === nib && inner_connection.from.node === busting_scope;
          });
          for (_l = 0, _len3 = inner_connections.length; _l < _len3; _l++) {
            inner_connection = inner_connections[_l];
            if (inner_connection.to.node === busting_scope) {
              through_connections.push({
                beginning_connection: connection,
                middle_connection: inner_connection
              });
            } else {
              new Connection({
                graph: this,
                from: clone_endpoint(connection.from),
                to: translate_endpoint(inner_connection.to)
              });
            }
          }
        }
        for (_m = 0, _len4 = through_connections.length; _m < _len4; _m++) {
          _ref4 = through_connections[_m], beginning_connection = _ref4.beginning_connection, middle_connection = _ref4.middle_connection;
          nib = middle_connection.to.nib;
          outer_connections = _.filter(this.connections, function(outer_connection) {
            return outer_connection.from.nib === nib && outer_connection.from.node === busting_node;
          });
          for (_n = 0, _len5 = outer_connections.length; _n < _len5; _n++) {
            outer_connection = outer_connections[_n];
            outer_connection.from = clone_endpoint(beginning_connection.from);
          }
        }
        outbound_connections = _.filter(this.connections, function(connection) {
          return connection.from.node === busting_node;
        });
        for (_o = 0, _len6 = outbound_connections.length; _o < _len6; _o++) {
          connection = outbound_connections[_o];
          nib = connection.from.nib;
          inner_connection = _.find(busting_scope.connections, function(connection) {
            return connection.to.node === busting_scope && connection.to.nib === nib;
          });
          if (inner_connection) {
            connection.from = translate_endpoint(inner_connection.from);
          }
        }
        return _.values(node_mapping);
      };

      Graph.prototype.make_from = function(old_graph, nodes) {
        /* Build a subroutine out of nodes in another subroutine.*/

        var connection, contained_connections, cross_threshhold, from_inside, group_connections, inbound_connections, new_node, node, outbound_connections, to_inside, _i, _j, _k, _len, _len1, _len2, _ref3, _ref4, _ref5,
          _this = this;
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          old_graph.remove_node(node);
          this.add_node(node);
        }
        new_node = new Call({
          graph: old_graph,
          position: V(0, 0),
          implementation: this
        });
        inbound_connections = [];
        outbound_connections = [];
        contained_connections = [];
        _ref3 = old_graph.connections;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          connection = _ref3[_j];
          from_inside = (_ref4 = connection.from.node, __indexOf.call(nodes, _ref4) >= 0);
          to_inside = (_ref5 = connection.to.node, __indexOf.call(nodes, _ref5) >= 0);
          if (from_inside && to_inside) {
            contained_connections.push(connection);
          } else if (from_inside) {
            outbound_connections.push(connection);
          } else if (to_inside) {
            inbound_connections.push(connection);
          }
        }
        for (_k = 0, _len2 = contained_connections.length; _k < _len2; _k++) {
          connection = contained_connections[_k];
          old_graph.remove_connection(connection);
          this.add_connection(connection);
        }
        group_connections = function(connections) {
          var groups, key, _l, _len3;
          groups = {};
          for (_l = 0, _len3 = connections.length; _l < _len3; _l++) {
            connection = connections[_l];
            key = "" + connection.from.nib.id + "-" + connection.from.node.id;
            if (groups[key] == null) {
              groups[key] = [];
            }
            groups[key].push(connection);
          }
          return _.values(groups);
        };
        cross_threshhold = function(connections, add_nib, direction, other_direction) {
          var data, group, new_nib, _l, _len3, _ref6, _results;
          _ref6 = group_connections(connections);
          _results = [];
          for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
            group = _ref6[_l];
            new_nib = _this[add_nib]();
            _results.push((function() {
              var _len4, _m, _results1;
              _results1 = [];
              for (_m = 0, _len4 = group.length; _m < _len4; _m++) {
                connection = group[_m];
                data = {
                  graph: this
                };
                data[direction] = clone_endpoint(connection[direction]);
                data[other_direction] = {
                  node: this,
                  nib: new_nib
                };
                new Connection(data);
                _results1.push(connection[direction] = {
                  node: new_node,
                  nib: new_nib
                });
              }
              return _results1;
            }).call(_this));
          }
          return _results;
        };
        cross_threshhold(inbound_connections, 'add_input', 'to', 'from');
        cross_threshhold(outbound_connections, 'add_output', 'from', 'to');
        return new_node;
      };

      /*
      find_strongly_connected_components: (collected={}, index=0)->
          @index = index
          index += 1
          collected[@id] = @
          for id,definition of @definitions_used()
              unless definition.index
                  definition.find_strongly_connected_components collected, index
              else
      */


      return Graph;

    })(Subroutine);
    strongly_connected_components = null;
    tarjan = function() {
      var components, definition, id, index, indexed, lowlink, stack, strongconnect, _ref3;
      index = 0;
      stack = [];
      indexed = {};
      lowlink = {};
      components = [];
      strongconnect = function(graph) {
        var dependency, id, new_component, node, _ref3;
        indexed[graph.id] = index;
        lowlink[graph.id] = index;
        index += 1;
        stack.push(graph);
        _ref3 = graph.definitions_used();
        for (id in _ref3) {
          dependency = _ref3[id];
          if (dependency instanceof Graph) {
            if (!(dependency.id in indexed)) {
              strongconnect(dependency);
              lowlink[graph.id] = Math.min(lowlink[graph.id], lowlink[dependency.id]);
            } else if (__indexOf.call(stack, dependency) >= 0) {
              lowlink[graph.id] = Math.min(lowlink[graph.id], indexed[dependency.id]);
            }
          }
        }
        if (lowlink[graph.id] === indexed[graph.id]) {
          new_component = [];
          while (true) {
            node = stack.pop();
            new_component.push(node);
            if (node.id === graph.id) {
              if (new_component.length > 1) {
                components.push(new_component);
              }
              return;
            }
          }
        }
      };
      for (id in all_definitions) {
        definition = all_definitions[id];
        if (definition instanceof Graph) {
          if (_ref3 = definition.id, __indexOf.call(indexed, _ref3) < 0) {
            strongconnect(definition);
          }
        }
      }
      strongly_connected_components = components;
      return components;
    };
    BoundLambda = (function(_super) {
      __extends(BoundLambda, _super);

      function BoundLambda(_arg) {
        this.scope = _arg.scope, this.node = _arg.node;
      }

      BoundLambda.prototype.invoke = function(output_nib, inputs, calling_scope) {
        /* TODO - Re-evaluate this comment
        Graph.evaluate_connection checks for these values in the scope,
        which provide inputs from the calling graph to the implementing graph.
        NOTE: it may not be possible to use a lambda within a lambda this way.
        */

        var defining_scope;
        defining_scope = this.scope;
        calling_scope.nodes.__proto__ = defining_scope.nodes;
        angular.extend(calling_scope, {
          lambda_value_generators: inputs,
          lambda_node: this.node
        });
        return this.node.graph.evaluate_connection(calling_scope, this.node, output_nib);
      };

      BoundLambda.prototype.get_name = function() {
        return this.node.get_name();
      };

      return BoundLambda;

    })(BaseType);
    Lambda = (function(_super) {
      __extends(Lambda, _super);

      function Lambda() {
        Lambda.__super__.constructor.apply(this, arguments);
        this.implementation_input = new Input({
          text: 'implementation',
          id: this.id
        });
      }

      Lambda.prototype.evaluate = function(scope, node) {
        /*
        This is called on lambda values, which are kinda like subgraphs.
        It returns a callable that is bound to the scope it was defined in,
        not the scope it will be called in.
        */

        return new BoundLambda({
          node: node,
          scope: scope
        });
      };

      Lambda.prototype.invoke = function(calling_scope, output_nib, node) {
        var implementation, inputs;
        inputs = calling_scope.inputs;
        implementation = inputs[0]();
        return implementation.invoke(output_nib, inputs.slice(1), calling_scope);
      };

      Lambda.prototype.get_call_sinks = function() {
        return [this.implementation_input].concat(this.inputs);
      };

      return Lambda;

    })(Graph);
    find_value = function(text, type, collection) {
      var id, thing;
      if (collection == null) {
        collection = all_definitions;
      }
      for (id in collection) {
        thing = collection[id];
        if (thing instanceof type) {
          if (!thing.text && thing.value === text) {
            return thing;
          }
        }
      }
    };
    make_value = function(graph, position, user_input, force_string) {
      var implementation, value;
      if (force_string == null) {
        force_string = false;
      }
      implementation = user_input instanceof Definition ? user_input : force_string ? (find_value(user_input, Text)) || new Text({
        value: user_input
      }) : (value = eval_expression(user_input), value instanceof String ? (find_value(value, Text)) || new Text({
        value: value
      }) : (find_value(user_input, JSON)) || new JSON({
        value: user_input
      }));
      return new Value({
        graph: graph,
        position: position,
        implementation: implementation
      });
    };
    Type = (function(_super) {
      __extends(Type, _super);

      function Type() {
        Type.__super__.constructor.apply(this, arguments);
        this.type_input = new Input({
          text: '',
          id: this.id
        });
      }

      Type.prototype.get_call_sinks = function() {
        return [this.type_input];
      };

      Type.prototype.get_value_sinks = function() {
        return this.inputs;
      };

      Type.prototype.get_call_sources = function() {
        return this.inputs;
      };

      Type.prototype.evaluate = function(scope, nib) {
        var result, value, _i, _len, _ref3, _ref4;
        result = {};
        _ref3 = _.zip(scope.inputs, this.inputs);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          _ref4 = _ref3[_i], value = _ref4[0], nib = _ref4[1];
          result[nib.text] = value();
        }
        return result;
      };

      Type.prototype.invoke = function(nib, input_values, scope, node, runtime) {
        var it;
        it = input_values[0]();
        return it[nib.text];
      };

      return Type;

    })(Subroutine);
    Symbol = (function(_super) {
      __extends(Symbol, _super);

      function Symbol() {
        _ref3 = Symbol.__super__.constructor.apply(this, arguments);
        return _ref3;
      }

      Symbol.prototype.evaluate = function() {
        return this.id;
      };

      Symbol.prototype.get_content_id = function() {
        return {
          type: 'symbol',
          id: this.id
        };
      };

      return Symbol;

    })(Definition);
    Literal = (function(_super) {
      __extends(Literal, _super);

      function Literal(_arg) {
        this.value = (_arg != null ? _arg : {}).value;
        Literal.__super__.constructor.apply(this, arguments);
      }

      Literal.prototype.toJSON = function() {
        return _.extend(Literal.__super__.toJSON.apply(this, arguments), {
          value: this.value
        });
      };

      Literal.prototype.get_content_id = function() {
        return {
          type: this.type,
          value: this.value
        };
      };

      return Literal;

    })(Definition);
    JSON = (function(_super) {
      __extends(JSON, _super);

      function JSON() {
        _ref4 = JSON.__super__.constructor.apply(this, arguments);
        return _ref4;
      }

      JSON.prototype.type = 'json';

      JSON.prototype.evaluate = function() {
        return eval_expression(this.value);
      };

      JSON.prototype.get_content_id = function() {};

      return JSON;

    })(Literal);
    Text = (function(_super) {
      __extends(Text, _super);

      function Text() {
        _ref5 = Text.__super__.constructor.apply(this, arguments);
        return _ref5;
      }

      Text.prototype.type = 'text';

      Text.prototype.evaluate = function() {
        return this.value;
      };

      Text.prototype.get_content_id = function() {
        return {
          type: 'text',
          value: this.value
        };
      };

      return Text;

    })(Literal);
    definition_classes = [Graph, JavaScript, CoffeeScript, JSON, Text, Symbol, Lambda, Type];
    definition_class_map = make_index_map(definition_classes, 'name');
    /* NODE TYPES*/

    Node = (function(_super) {
      __extends(Node, _super);

      function Node(_arg) {
        var _ref6;
        _ref6 = _arg != null ? _arg : {}, this.graph = _ref6.graph, this.id = _ref6.id, this.position = _ref6.position, this.implementation = _ref6.implementation;
        if (this.id == null) {
          this.id = UUID();
        }
        this.graph.nodes.push(this);
      }

      Node.prototype["delete"] = function() {
        this.graph.delete_node_connections(this);
        return this.graph.remove_node(this);
      };

      Node.prototype.toJSON = function() {
        return _.extend(Node.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          implementation_id: this.implementation.id,
          position: this.position
        });
      };

      Node.prototype.clone = function(new_scope) {
        var data, new_node, old_id;
        data = window.JSON.parse(window.JSON.stringify(this));
        old_id = data.id;
        data.id = UUID();
        new_node = resurrect_node(new_scope, data);
        new_node.old_id = old_id;
        return new_node;
      };

      Node.prototype.virtual_inputs = function(scope) {
        var sink, _i, _len, _ref6, _results,
          _this = this;
        _ref6 = this.get_node_sinks();
        _results = [];
        for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
          sink = _ref6[_i];
          _results.push((function(sink) {
            return function() {
              return _this.graph.evaluate_connection(scope, _this, sink);
            };
          })(sink));
        }
        return _results;
      };

      Node.prototype.get_name = function() {
        return this.implementation.text;
      };

      return Node;

    })(BaseType);
    Call = (function(_super) {
      __extends(Call, _super);

      function Call() {
        _ref6 = Call.__super__.constructor.apply(this, arguments);
        return _ref6;
      }

      Call.prototype.evaluate = function(parent_scope, output_nib) {
        var scope;
        scope = parent_scope.nodes[this.id];
        if (scope == null) {
          scope = parent_scope.nodes[this.id] = make_child_scope(parent_scope, {
            inputs: this.virtual_inputs(parent_scope)
          });
        }
        if (!(output_nib.id in scope.output_values)) {
          scope.output_values[output_nib.id] = this.implementation.invoke(scope, output_nib, this);
        }
        return scope.output_values[output_nib.id];
      };

      Call.prototype.get_node_sinks = function() {
        return this.implementation.get_call_sinks();
      };

      Call.prototype.get_node_sources = function() {
        return this.implementation.get_call_sources();
      };

      /*
      subroutines_referenced: ->
          # TODO: UPDATE
          return [] unless @implementation instanceof Graph
          results = []
          for input in @inputs
              parent = input.get_connection()?.connection.output.parent
              if parent
                  results.push parent.id if parent.type is 'function'
                  resuts = results.concat parent.subroutines_referenced()
          return results
      */


      return Call;

    })(Node);
    Value = (function(_super) {
      __extends(Value, _super);

      function Value() {
        Value.__super__.constructor.apply(this, arguments);
        this.outputs = [value_output_nib];
        this.children = [];
      }

      Value.prototype.type = 'value';

      Value.prototype.evaluate = function(parent_scope, output_nib) {
        return this.implementation.evaluate(parent_scope, this);
      };

      Value.prototype.subroutines_referenced = function() {
        return [];
      };

      Value.prototype.get_node_sinks = function() {
        return this.implementation.get_value_sinks();
      };

      Value.prototype.get_node_sources = function() {
        return this.outputs;
      };

      Value.prototype.add_child = function(node) {
        if (__indexOf.call(this.children, node) < 0) {
          node.lambda_node = this;
          return this.children.push(node);
        }
      };

      Value.prototype.remove_child = function(node) {
        node.lambda_node = null;
        return this.children = _.without(this.children, node);
      };

      Value.prototype.toJSON = function() {
        var child;
        return _.extend(Value.__super__.toJSON.apply(this, arguments), {
          children: (function() {
            var _i, _len, _ref7, _results;
            _ref7 = this.children;
            _results = [];
            for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
              child = _ref7[_i];
              _results.push(child.id);
            }
            return _results;
          }).call(this)
        });
      };

      return Value;

    })(Node);
    UnknownNode = (function(_super) {
      __extends(UnknownNode, _super);

      function UnknownNode(position, type, text, id) {
        this.position = position;
        this.id = id;
        this.type = 'unknown';
        this.text = "Unknown " + type + ": " + text;
        this.inputs = [];
        this.outputs = [];
        UnknownNode.__super__.constructor.apply(this, arguments);
      }

      return UnknownNode;

    })(Node);
    node_classes = [Call, Value];
    node_class_map = make_index_map(node_classes, 'name');
    /* OTHER TYPES*/

    Nib = (function() {
      function Nib(_arg) {
        var _ref7;
        _ref7 = _arg != null ? _arg : {}, this.text = _ref7.text, this.id = _ref7.id, this.index = _ref7.index, this.n_ary = _ref7.n_ary, this.default_value = _ref7.default_value;
        if (this.id !== null) {
          if (this.id == null) {
            this.id = UUID();
          }
        }
        if (this.n_ary == null) {
          this.n_ary = false;
        }
      }

      Nib.prototype.initialize = function() {
        return this;
      };

      Nib.prototype.toJSON = function() {
        return {
          text: this.text,
          id: this.id,
          n_ary: this.n_ary,
          default_value: this.default_value
        };
      };

      return Nib;

    })();
    Input = (function(_super) {
      __extends(Input, _super);

      function Input() {
        _ref7 = Input.__super__.constructor.apply(this, arguments);
        return _ref7;
      }

      return Input;

    })(Nib);
    Output = (function(_super) {
      __extends(Output, _super);

      function Output() {
        _ref8 = Output.__super__.constructor.apply(this, arguments);
        return _ref8;
      }

      return Output;

    })(Nib);
    Connection = (function() {
      function Connection(_arg) {
        var _base, _base1, _ref9;
        _ref9 = _arg != null ? _arg : {}, this.graph = _ref9.graph, this.from = _ref9.from, this.to = _ref9.to, this.id = _ref9.id;
        if (this.id == null) {
          this.id = UUID();
        }
        this.graph.connections.push(this);
        if ((_base = this.to).index == null) {
          _base.index = 0;
        }
        if ((_base1 = this.from).index == null) {
          _base1.index = 0;
        }
        if (!(this.from instanceof Object && this.to instanceof Object)) {
          throw "WTF";
        }
      }

      Connection.prototype.toJSON = function() {
        return {
          from: {
            nib: this.from.nib.id,
            node: this.from.node.id,
            index: this.from.node.index,
            internal: this.from.internal
          },
          to: {
            nib: this.to.nib.id,
            node: this.to.node.id,
            index: this.to.node.index,
            internal: this.to.internal
          }
        };
      };

      return Connection;

    })();
    value_output_nib = new Output({
      id: 'value_output',
      index: 0
    });
    sequencer_input_nib = new Input({
      id: 'sequencer_input',
      index: 0,
      text: ';'
    });
    sequencer_output_nib = new Output({
      id: 'sequencer_output',
      index: 0,
      text: ';'
    });
    is_input = function(it) {
      var is_input_class;
      is_input_class = it.nib instanceof Input;
      if (it.node instanceof Graph || (it.node instanceof Call && it.node.implementation instanceof Type) || it.internal) {
        return is_input_class;
      } else {
        return !is_input_class;
      }
    };
    make_connection = function(graph, _arg) {
      var connector, from, from_input, to, to_input, _i, _len, _ref10, _ref9;
      from = _arg.from, to = _arg.to;
      _ref9 = [to, from];
      for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
        connector = _ref9[_i];
        if (connector.node.implementation instanceof Lambda && connector.node instanceof Value && connector.nib !== value_output_nib) {
          connector.internal = true;
        }
      }
      from_input = is_input(from);
      to_input = is_input(to);
      if (!((from_input && !to_input) || (to_input && !from_input))) {
        return;
      }
      if (to_input) {
        _ref10 = [to, from], from = _ref10[0], to = _ref10[1];
      }
      graph.delete_connections('to', to.node, to.nib);
      return new Connection({
        graph: graph,
        from: from,
        to: to
      });
    };
    find_nib_uses = function(nib, direction) {
      var connection, id, subroutine, uses, _i, _len, _ref9;
      if (direction == null) {
        direction = 'to';
      }
      uses = {};
      for (id in all_definitions) {
        subroutine = all_definitions[id];
        if (!(subroutine instanceof Graph)) {
          continue;
        }
        _ref9 = subroutine.connections;
        for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
          connection = _ref9[_i];
          if (connection[direction].nib === nib) {
            uses[subroutine.id] = subroutine;
          }
        }
      }
      return uses;
    };
    dissociate_exception = function(procedure) {
      var exception;
      try {
        return procedure();
      } catch (_error) {
        exception = _error;
        return $timeout(function() {
          throw exception;
        });
      }
    };
    execute = function(runtime, routine) {
      var exception;
      try {
        return runtime.log(window.JSON.stringify(routine()));
      } catch (_error) {
        exception = _error;
        if (exception instanceof RuntimeException) {
          return runtime.log("Error: " + exception.constructor.name + ": " + exception.message);
        } else {
          throw exception;
        }
      }
    };
    ignore_if_disconnected = function(procedure) {
      var exception;
      try {
        return procedure();
      } catch (_error) {
        exception = _error;
        if (!(exception instanceof NotConnected)) {
          throw exception;
        }
      }
    };
    start_saving = function() {
      return setInterval(save_state, 500);
    };
    save_state = function() {
      var state;
      state = {
        definitions: _.values(all_definitions),
        schema_version: schema_version
      };
      return localStorage.state = window.JSON.stringify(state);
    };
    load_state = function(data) {
      var builtin, builtin_data, definition_data, graph, id, implementation_pass, instance, second_pass, subroutine, subroutine_data, subroutines, the_class, transform_definition_data, transform_nib_data, _i, _j, _len, _len1, _ref10, _ref11, _ref12, _ref13, _ref9;
      switch (data.schema_version) {
        case 1:
          subroutines = {};
          second_pass = [];
          transform_nib_data = function(nib_texts) {
            var index, text, _i, _len, _results;
            _results = [];
            for (index = _i = 0, _len = nib_texts.length; _i < _len; index = ++_i) {
              text = nib_texts[index];
              _results.push({
                text: text,
                index: index
              });
            }
            return _results;
          };
          transform_definition_data = function(definition_data) {
            definition_data.inputs = transform_nib_data(definition_data.inputs);
            definition_data.outputs = transform_nib_data(definition_data.outputs);
            return definition_data.text = definition_data.name;
          };
          _ref9 = data.builtins;
          for (id in _ref9) {
            builtin_data = _ref9[id];
            transform_definition_data(builtin_data);
            builtin = new JavaScript(builtin_data);
            subroutines[builtin.id] = builtin;
          }
          _ref10 = data.subroutines;
          for (id in _ref10) {
            subroutine_data = _ref10[id];
            transform_definition_data(subroutine_data);
            subroutine_data.text = subroutine_data.name;
            subroutine = new Graph(subroutine_data);
            subroutines[subroutine.id] = subroutine;
            second_pass.push(subroutine);
          }
          for (_i = 0, _len = second_pass.length; _i < _len; _i++) {
            subroutine = second_pass[_i];
            load_implementation(subroutine, data.subroutines[subroutine.id], subroutines);
          }
          return all_definitions;
        case 2:
          implementation_pass = [];
          _ref11 = data.definitions;
          for (id in _ref11) {
            definition_data = _ref11[id];
            if (definition_data.type === 'JSONLiteral') {
              definition_data.type = 'JSON';
            } else if (definition_data.type === 'StringLiteral') {
              definition_data.type = 'Text';
            }
            if ((_ref12 = definition_data.type) === 'JSON' || _ref12 === 'Text') {
              if (definition_data.value == null) {
                definition_data.value = definition_data.text;
              }
              if (definition_data.value === definition_data.text) {
                delete definition_data.text;
              }
            }
            the_class = definition_class_map[definition_data.type];
            instance = new the_class(definition_data);
            if (instance instanceof Graph) {
              implementation_pass.push({
                graph: instance,
                data: definition_data
              });
            }
          }
          for (_j = 0, _len1 = implementation_pass.length; _j < _len1; _j++) {
            _ref13 = implementation_pass[_j], graph = _ref13.graph, data = _ref13.data;
            load_implementation_v2(graph, data);
          }
          return all_definitions;
      }
    };
    resurrect_node = function(graph, node_data) {
      var implementation, node, node_class, position;
      node_class = node_class_map[node_data.type];
      position = V(node_data.position);
      implementation = all_definitions[node_data.implementation_id];
      node = new node_class({
        graph: graph,
        position: position,
        implementation: implementation,
        id: node_data.id
      });
      node.child_ids = node_data.children;
      return node;
    };
    is_lambda_value = function(node) {
      return (node instanceof Value) && (node.implementation instanceof Lambda);
    };
    load_implementation_v2 = function(graph, data) {
      var child_id, child_node, connection_data, from_nib, from_node, get_nib, get_node, node, node_data, to_nib, to_node, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref10, _ref11, _ref12, _ref9, _results;
      _ref9 = data.nodes;
      for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
        node_data = _ref9[_i];
        resurrect_node(graph, node_data);
      }
      _ref10 = graph.nodes;
      for (_j = 0, _len1 = _ref10.length; _j < _len1; _j++) {
        node = _ref10[_j];
        if ((is_lambda_value(node)) && node.child_ids) {
          _ref11 = node.child_ids;
          for (_k = 0, _len2 = _ref11.length; _k < _len2; _k++) {
            child_id = _ref11[_k];
            child_node = node.graph.find_node(child_id);
            if (child_node) {
              node.add_child(child_node);
            }
          }
        }
      }
      _ref12 = data.connections;
      _results = [];
      for (_l = 0, _len3 = _ref12.length; _l < _len3; _l++) {
        connection_data = _ref12[_l];
        get_node = function(direction) {
          var id;
          id = connection_data[direction].node;
          if (id === graph.id) {
            return graph;
          } else {
            return _.find(graph.nodes, function(node) {
              return node.id === id;
            });
          }
        };
        from_node = get_node('from');
        to_node = get_node('to');
        get_nib = function(node, connector, nib_type) {
          var nibs;
          if (connector.internal) {
            nibs = node.implementation["get_node_" + nib_type]();
            return _.find(nibs, function(nib) {
              return nib.id === connector.nib;
            });
          } else {
            nibs = node["get_node_" + nib_type]();
            return _.find(nibs, function(nib) {
              return nib.id === connector.nib || (nib.id === 'value_output' && connector.nib === null);
            });
          }
        };
        from_nib = get_nib(from_node, connection_data['from'], 'sources');
        to_nib = get_nib(to_node, connection_data['to'], 'sinks');
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          graph: graph,
          from: {
            node: from_node,
            nib: from_nib,
            internal: connection_data.from.internal
          },
          to: {
            node: to_node,
            nib: to_nib,
            internal: connection_data.to.internal
          }
        }));
      }
      return _results;
    };
    load_implementation = function(subroutine, data, subroutines) {
      var connection_data, found_value, from_nib, from_node, get_node, implementation, node, position, to_nib, to_node, value, _i, _j, _len, _len1, _ref10, _ref9, _results;
      _ref9 = data.nodes;
      for (_i = 0, _len = _ref9.length; _i < _len; _i++) {
        node = _ref9[_i];
        position = V(node.position);
        if (node.type === 'literal') {
          implementation = 'implementation_id' in node ? subroutines[node.implementation_id] : (found_value = find_value(node.text, JSON, subroutines), found_value ? found_value : (value = new JSON({
            text: node.text
          }), subroutines[value.id] = value, value));
          new Value({
            graph: subroutine,
            position: position,
            implementation: implementation,
            id: node.id
          });
        } else {
          implementation = subroutines[node.implementation_id];
          if (implementation) {
            new Call({
              graph: subroutine,
              position: position,
              implementation: implementation,
              id: node.id
            });
          } else {
            new UnknownNode(position, node.type, node.text, node.id);
          }
        }
      }
      _ref10 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref10.length; _j < _len1; _j++) {
        connection_data = _ref10[_j];
        get_node = function(nib) {
          if (nib.parent_id === subroutine.id) {
            return subroutine;
          } else {
            return _.find(subroutine.nodes, function(node) {
              return node.id === nib.parent_id;
            });
          }
        };
        from_node = get_node(connection_data.output);
        to_node = get_node(connection_data.input);
        from_nib = from_node.get_node_sources()[connection_data.output.index];
        to_nib = to_node.get_node_sinks()[connection_data.input.index];
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          graph: subroutine,
          from: {
            node: from_node,
            nib: from_nib
          },
          to: {
            node: to_node,
            nib: to_nib
          }
        }));
      }
      return _results;
    };
    if (localStorage.state != null) {
      source_data = window.JSON.parse(localStorage.state);
    } else {
      source_data_deferred = $q.defer();
      source_data = source_data_deferred.promise;
      $http.get('examples.json').success(function(data) {
        return source_data_deferred.resolve(data);
      });
    }
    all_definitions = {};
    loaded = $q.defer();
    $q.when(source_data, function(source_data) {
      var id, obj, _ref9;
      _ref9 = load_state(source_data);
      for (id in _ref9) {
        obj = _ref9[id];
        all_definitions[id] = obj;
      }
      loaded.resolve(true);
      if (window.location.search !== '?debug') {
        return start_saving();
      }
    });
    return {
      make_connection: make_connection,
      find_nib_uses: find_nib_uses,
      make_value: make_value,
      loaded: loaded.promise,
      tarjan: tarjan,
      is_lambda_value: is_lambda_value,
      RuntimeException: RuntimeException,
      Exit: Exit,
      InputError: InputError,
      NotConnected: NotConnected,
      NotImplemented: NotImplemented,
      BuiltinSyntaxError: CodeSyntaxError,
      definition_types: definition_classes,
      Definition: Definition,
      BaseType: BaseType,
      Subroutine: Subroutine,
      Graph: Graph,
      Code: Code,
      JavaScript: JavaScript,
      CoffeeScript: CoffeeScript,
      Lambda: Lambda,
      Type: Type,
      Literal: Literal,
      JSON: JSON,
      Text: Text,
      Symbol: Symbol,
      Node: Node,
      Call: Call,
      Value: Value,
      Input: Input,
      Output: Output,
      Connection: Connection,
      subroutines: all_definitions,
      Runtime: Runtime
    };
  });

}).call(this);

/*
//@ sourceMappingURL=language.map
*/
