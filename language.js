// Generated by CoffeeScript 1.3.3
(function() {
  var module,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  module = angular.module('vislang');

  module.factory('interpreter', function($q, $http) {
    var Call, CodeSyntaxError, Connection, Definition, Exit, Graph, Input, InputError, JSONLiteral, JavaScript, Literal, Nib, Node, NotConnected, NotImplemented, Output, RuntimeException, StringLiteral, Subroutine, Type, UnknownNode, Value, all_definitions, clone_endpoint, definition_class_map, definition_classes, dissociate_exception, eval_expression, execute, find_nib_uses, find_value, ignore_if_disconnected, is_input, load_implementation, load_implementation_v2, load_state, loaded, make_connection, make_index_map, make_value, node_class_map, node_classes, resurrect_node, save_state, schema_version, source_data, source_data_deferred, start_saving, value_output_nib;
    schema_version = 2;
    make_index_map = function(objects, attribute) {
      var obj, result, _i, _len;
      result = {};
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        result[obj[attribute]] = obj;
      }
      return result;
    };
    clone_endpoint = function(endpoint) {
      return {
        node: endpoint.node,
        nib: endpoint.nib
      };
    };
    /* EXCEPTION TYPES
    */

    RuntimeException = (function() {

      function RuntimeException(message) {
        this.message = message;
      }

      return RuntimeException;

    })();
    Exit = (function(_super) {

      __extends(Exit, _super);

      function Exit() {
        this.message = "Exit Signal";
      }

      return Exit;

    })(RuntimeException);
    InputError = (function(_super) {

      __extends(InputError, _super);

      function InputError() {
        this.message = "Cancelled execution due to lack of input";
      }

      return InputError;

    })(RuntimeException);
    NotConnected = (function(_super) {

      __extends(NotConnected, _super);

      function NotConnected() {
        this.message = "Something in the program is disconnected";
      }

      return NotConnected;

    })(RuntimeException);
    NotImplemented = (function(_super) {

      __extends(NotImplemented, _super);

      function NotImplemented(name) {
        this.name = name;
        this.message = "JavaScript \"" + this.name + "\" is not implemented";
      }

      return NotImplemented;

    })(RuntimeException);
    CodeSyntaxError = (function(_super) {

      __extends(CodeSyntaxError, _super);

      function CodeSyntaxError(name, exception) {
        this.name = name;
        this.exception = exception;
        this.message = "" + exception + " in builtin \"" + this.name + "\": ";
      }

      return CodeSyntaxError;

    })(RuntimeException);
    /* DEFINITION TYPES
    */

    Type = (function() {

      function Type() {}

      Type.prototype.toJSON = function() {
        return {
          type: this.constructor.name
        };
      };

      return Type;

    })();
    Definition = (function(_super) {

      __extends(Definition, _super);

      function Definition(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.id = _ref.id, this.text = _ref.text;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        all_definitions[this.id] = this;
      }

      Definition.prototype.fromJSON = function() {
        return this;
      };

      Definition.prototype.initialize = function() {
        return this;
      };

      Definition.prototype.toJSON = function() {
        return _.extend(Definition.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          text: this.text
        });
      };

      Definition.prototype.find_nib = function(id) {
        var nib, _i, _len, _ref;
        _ref = this.inputs.concat(this.outputs);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nib = _ref[_i];
          if (nib.id === id) {
            return nib;
          }
        }
      };

      return Definition;

    })(Type);
    Subroutine = (function(_super) {

      __extends(Subroutine, _super);

      function Subroutine(_arg) {
        var data, inputs, outputs, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        _ref = _arg != null ? _arg : {}, inputs = _ref.inputs, outputs = _ref.outputs;
        Subroutine.__super__.constructor.apply(this, arguments);
        this.inputs = [];
        this.outputs = [];
        _ref1 = inputs || [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          data = _ref1[_i];
          this.add_input(data);
        }
        _ref2 = outputs || [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          data = _ref2[_j];
          this.add_output(data);
        }
      }

      Subroutine.prototype.user_inputs = function() {
        var input, input_values, _fn, _i, _len, _ref;
        input_values = [];
        _ref = this.inputs;
        _fn = function(input) {
          var value;
          value = _.memoize(function() {
            var result;
            result = prompt("Provide a JSON value for input " + input.index + ": \"" + input.text + "\"");
            if (result === null) {
              throw new Exit("cancelled execution");
            }
            try {
              return JSON.parse(result);
            } catch (exception) {
              if (exception instanceof SyntaxError) {
                throw new InputError(result);
              } else {
                throw exception;
              }
            }
          });
          return input_values.push(value);
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          _fn(input);
        }
        return input_values;
      };

      Subroutine.prototype.run = function(nib) {
        var input_values,
          _this = this;
        input_values = this.user_inputs();
        try {
          return setTimeout(function() {
            return execute(function() {
              return _this.invoke(nib, input_values);
            });
          });
        } catch (exception) {
          if (exception instanceof InputError) {
            return alert("Invalid JSON: " + exception.message);
          } else {
            throw exception;
          }
        }
      };

      Subroutine.prototype.delete_nib = function(nib, group) {
        var index, _i, _len, _ref, _results;
        this[group] = _.without(this[group], nib);
        _ref = this[group];
        _results = [];
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          nib = _ref[index];
          _results.push(nib.index = index);
        }
        return _results;
        /*
                    delete_index = @[group].indexOf nib
                    @[group].splice delete_index, 1
                    for index in [delete_index...@[group].length]
                        @[group][index].index -= 1
        */

      };

      Subroutine.prototype.add_nib = function(group, the_class, data) {
        var nib;
        if (data == null) {
          data = {};
        }
        nib = new the_class(_.extend(data, {
          scope: this,
          index: this[group].length
        }));
        this[group].push(nib);
        return nib;
      };

      Subroutine.prototype.delete_input = function(nib) {
        return this.delete_nib(nib, 'inputs');
      };

      Subroutine.prototype.delete_output = function(nib) {
        return this.delete_nib(nib, 'outputs');
      };

      Subroutine.prototype.add_input = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('inputs', Input, data);
      };

      Subroutine.prototype.add_output = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('outputs', Output, data);
      };

      Subroutine.prototype.toJSON = function() {
        return _.extend(Subroutine.__super__.toJSON.apply(this, arguments), {
          inputs: this.inputs,
          outputs: this.outputs
        });
      };

      Subroutine.prototype.get_inputs = function() {
        return this.outputs;
      };

      Subroutine.prototype.get_outputs = function() {
        return this.inputs;
      };

      Subroutine.prototype.evaluate = function() {
        return this;
      };

      return Subroutine;

    })(Definition);
    JavaScript = (function(_super) {

      __extends(JavaScript, _super);

      JavaScript.prototype.type = 'javascript';

      function JavaScript(_arg) {
        var _ref;
        _ref = _arg != null ? _arg : {}, this.memo_implementation = _ref.memo_implementation, this.output_implementation = _ref.output_implementation;
        JavaScript.__super__.constructor.apply(this, arguments);
      }

      JavaScript.prototype.toJSON = function() {
        return _.extend(JavaScript.__super__.toJSON.apply(this, arguments), {
          memo_implementation: this.memo_implementation,
          output_implementation: this.output_implementation
        });
      };

      JavaScript.prototype["export"] = function() {
        var builtins;
        builtins = {};
        builtins[this.id] = this;
        return {
          all_definitions: {},
          builtins: builtins,
          schema_version: schema_version
        };
      };

      JavaScript.prototype.invoke = function(output_nib, inputs, scope, node) {
        var args, memo_function, output_function;
        try {
          memo_function = eval_expression(this.memo_implementation);
          output_function = eval_expression(this.output_implementation);
        } catch (exception) {
          if (exception instanceof SyntaxError) {
            throw new CodeSyntaxError(this.text, exception);
          } else {
            throw exception;
          }
        }
        if (!output_function) {
          throw new NotImplemented(this.text);
        }
        args = inputs.concat([output_nib.index]);
        if (scope && memo_function && !(node.id in scope.memos)) {
          scope.memos[node.id] = memo_function.apply(null, args);
        }
        return output_function.apply(null, args.concat([scope != null ? scope.memos[node.id] : void 0]));
      };

      return JavaScript;

    })(Subroutine);
    Graph = (function(_super) {

      __extends(Graph, _super);

      Graph.prototype.type = 'graph';

      function Graph() {
        Graph.__super__.constructor.apply(this, arguments);
        this.nodes = [];
        this.connections = [];
      }

      Graph.prototype.toJSON = function() {
        return _.extend(Graph.__super__.toJSON.apply(this, arguments), {
          nodes: this.nodes,
          connections: this.connections
        });
      };

      /* RUNNING
      */


      Graph.prototype.invoke = function(output_nib, inputs) {
        /* Evaluates an output in a fresh scope
        */

        var scope;
        scope = {
          subroutine: this,
          inputs: inputs,
          memos: {}
        };
        return this.evaluate_connection(scope, this, output_nib);
      };

      Graph.prototype.evaluate_connection = function(scope, to_node, to_nib) {
        /* This helper will follow a connection and evaluate whatever it finds
        */

        var connection, nib, node, _ref;
        connection = this.find_connection('to', to_node, to_nib);
        if (!connection) {
          throw new NotConnected;
        }
        _ref = connection.from, node = _ref.node, nib = _ref.nib;
        if (node instanceof Graph) {
          return scope.inputs[nib.index]();
        } else {
          return node.evaluate(scope, nib);
        }
      };

      Graph.prototype.find_connection = function(direction, node, nib) {
        /* Use this to determine how nodes are connected
        */

        var connection, _i, _len, _ref;
        _ref = this.connections;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          connection = _ref[_i];
          if (connection[direction].node.id === node.id && connection[direction].nib.id === nib.id) {
            return connection;
          }
        }
        return void 0;
      };

      Graph.prototype.delete_connections = function(direction, node, nib) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection[direction].node === node && connection[direction].nib === nib;
        });
      };

      Graph.prototype.delete_node_connections = function(node) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection.from.node === node || connection.to.node === node;
        });
      };

      Graph.prototype.delete_nodes = function(nodes) {
        this.connections = _.reject(this.connections, function(connection) {
          var _ref, _ref1;
          return (_ref = connection.from.node, __indexOf.call(nodes, _ref) >= 0) || (_ref1 = connection.to.node, __indexOf.call(nodes, _ref1) >= 0);
        });
        return this.nodes = _.without.apply(_, [this.nodes].concat(__slice.call(nodes)));
      };

      Graph.prototype["export"] = function() {
        var dependencies;
        dependencies = this.get_dependencies();
        dependencies.schema_version = schema_version;
        return dependencies;
      };

      Graph.prototype.delete_input = function(nib) {
        this.delete_connections('to', this, nib);
        return Graph.__super__.delete_input.call(this, nib);
      };

      Graph.prototype.delete_output = function(nib) {
        this.delete_connections('from', this, nib);
        return Graph.__super__.delete_output.call(this, nib);
      };

      Graph.prototype.remove_node = function(node) {
        return this.nodes = _.without(this.nodes, node);
      };

      Graph.prototype.add_node = function(node) {
        return this.nodes.push(node);
      };

      Graph.prototype.remove_connection = function(connection) {
        return this.connections = _.without(this.connections, connection);
      };

      Graph.prototype.add_connection = function(connection) {
        return this.connections.push(connection);
      };

      /* probably outdated
      get_dependencies: (dependencies={subroutines:{},builtins:{}}) ->
          # TODO: UPDATE
          dependencies.subroutines[@id] = @ if @id not of dependencies.subroutines
          for id, node of @nodes
              if node instanceof SubroutineApplication
                  child_dependencies = node.implementation.get_dependencies dependencies
                  _.extend dependencies.subroutines, child_dependencies.subroutines
                  _.extend dependencies.builtins, child_dependencies.builtins
              else if node instanceof BuiltinApplication
                  dependencies.builtins[@id] = node.implementation
          dependencies
      
      subroutines_referenced: ->
          # TODO: UPDATE
          # TODO: turn this into a cleanup function
          results = []
          for output in @outputs
              parent = output.get_connection()?.connection.output.parent
              if parent
                  results.push parent.id if parent.type is 'function'
                  resuts = results.concat parent.subroutines_referenced()
          return results
      
      build_adjacency_list: ->
          # clear prior data
          for id, node of @nodes
              node.adjacency_id = null
      
          adjacency_list = []
      
          # number and add self first
          adjacency_list.push
              node:@
              connections:[]
          @adjacency_id = 0
      
          # number all the connected nodes in a predictable way, and add them to the list
          input_queue = [].concat @outputs
          while input_queue.length > 0
              input = input_queue.shift()
              node = input.get_node()
              # NOTE: if node is a subroutine then we've reached ourselves again
              if node instanceof Node and node.adjacency_id is null
                  item_count = adjacency_list.push
                      node:node
                      connections:[]
                  node.adjacency_id = item_count - 1 # length is offset by 1 from index
                  input_queue = input_queue.concat node.inputs
      
          # record all the connections based on the consistent numbering scheme
          for item in adjacency_list
              nibs = if item.node instanceof Node then item.node.inputs else item.node.outputs
              for input, input_index in nibs
                  node = input.parent
                  item.connections[input_index] = node.adjacency_id
      
          adjacency_list
      */


      Graph.prototype.bust_node = function(busting_node) {
        var beginning_connection, busting_scope, connection, inbound_connections, inner_connection, inner_connections, internal_connections, middle_connection, new_node, nib, node, node_mapping, outbound_connections, outer_connection, outer_connections, through_connections, translate_endpoint, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1,
          _this = this;
        this.remove_node(busting_node);
        busting_scope = busting_node.implementation;
        node_mapping = {};
        _ref = busting_scope.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          new_node = node.clone(this);
          node_mapping[node.id] = new_node;
        }
        translate_endpoint = function(endpoint) {
          return {
            node: node_mapping[endpoint.node.id],
            nib: endpoint.nib
          };
        };
        internal_connections = _.filter(busting_scope.connections, function(connection) {
          return connection.from.node !== busting_scope && connection.to.node !== busting_scope;
        });
        for (_j = 0, _len1 = internal_connections.length; _j < _len1; _j++) {
          connection = internal_connections[_j];
          new Connection({
            scope: this,
            from: translate_endpoint(connection.from),
            to: translate_endpoint(connection.to)
          });
        }
        inbound_connections = _.filter(this.connections, function(connection) {
          return connection.to.node === busting_node;
        });
        through_connections = [];
        for (_k = 0, _len2 = inbound_connections.length; _k < _len2; _k++) {
          connection = inbound_connections[_k];
          this.remove_connection(connection);
          nib = connection.to.nib;
          inner_connections = _.filter(busting_scope.connections, function(inner_connection) {
            return inner_connection.from.nib === nib && inner_connection.from.node === busting_scope;
          });
          for (_l = 0, _len3 = inner_connections.length; _l < _len3; _l++) {
            inner_connection = inner_connections[_l];
            if (inner_connection.to.node === busting_scope) {
              through_connections.push({
                beginning_connection: connection,
                middle_connection: inner_connection
              });
            } else {
              new Connection({
                scope: this,
                from: clone_endpoint(connection.from),
                to: translate_endpoint(inner_connection.to)
              });
            }
          }
        }
        for (_m = 0, _len4 = through_connections.length; _m < _len4; _m++) {
          _ref1 = through_connections[_m], beginning_connection = _ref1.beginning_connection, middle_connection = _ref1.middle_connection;
          nib = middle_connection.to.nib;
          outer_connections = _.filter(this.connections, function(outer_connection) {
            return outer_connection.from.nib === nib && outer_connection.from.node === busting_node;
          });
          for (_n = 0, _len5 = outer_connections.length; _n < _len5; _n++) {
            outer_connection = outer_connections[_n];
            outer_connection.from = clone_endpoint(beginning_connection.from);
          }
        }
        outbound_connections = _.filter(this.connections, function(connection) {
          return connection.from.node === busting_node;
        });
        for (_o = 0, _len6 = outbound_connections.length; _o < _len6; _o++) {
          connection = outbound_connections[_o];
          nib = connection.from.nib;
          inner_connection = _.find(busting_scope.connections, function(connection) {
            return connection.to.node === busting_scope && connection.to.nib === nib;
          });
          if (inner_connection) {
            connection.from = translate_endpoint(inner_connection.from);
          }
        }
        return _.values(node_mapping);
      };

      Graph.prototype.make_from = function(nodes) {
        /* Build a subroutine out of nodes in another subroutine.
        */

        var connection, contained_connections, from_inside, grouping, id, inbound_connections, inbound_connections_by_nib, key, new_connection, new_nib, new_node, nib, node, old_scope, outbound_connections, outbound_connections_by_nib, to_inside, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _name, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        old_scope = nodes[0].scope;
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          old_scope.remove_node(node);
          this.add_node(node);
        }
        new_node = new Call({
          scope: old_scope,
          position: V(0, 0),
          implementation: this
        });
        inbound_connections = [];
        outbound_connections = [];
        contained_connections = [];
        _ref = old_scope.connections;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          connection = _ref[_j];
          from_inside = (_ref1 = connection.from.node, __indexOf.call(nodes, _ref1) >= 0);
          to_inside = (_ref2 = connection.to.node, __indexOf.call(nodes, _ref2) >= 0);
          if (from_inside && to_inside) {
            contained_connections.push(connection);
          } else if (from_inside) {
            outbound_connections.push(connection);
          } else if (to_inside) {
            inbound_connections.push(connection);
          }
        }
        for (_k = 0, _len2 = contained_connections.length; _k < _len2; _k++) {
          connection = contained_connections[_k];
          old_scope.remove_connection(connection);
          this.add_connection(connection);
        }
        inbound_connections_by_nib = {};
        for (_l = 0, _len3 = inbound_connections.length; _l < _len3; _l++) {
          connection = inbound_connections[_l];
          nib = connection.from.nib;
          if ((_ref3 = inbound_connections_by_nib[_name = nib.id]) == null) {
            inbound_connections_by_nib[_name] = {
              nib: nib,
              connections: []
            };
          }
          inbound_connections_by_nib[nib.id].connections.push(connection);
        }
        for (id in inbound_connections_by_nib) {
          grouping = inbound_connections_by_nib[id];
          new_nib = this.add_input();
          _ref4 = grouping.connections;
          for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
            connection = _ref4[_m];
            new_connection = new Connection({
              scope: this,
              to: clone_endpoint(connection.to),
              from: {
                node: this,
                nib: new_nib
              }
            });
            connection.to = {
              node: new_node,
              nib: new_nib
            };
          }
        }
        outbound_connections_by_nib = {};
        for (_n = 0, _len5 = outbound_connections.length; _n < _len5; _n++) {
          connection = outbound_connections[_n];
          key = "" + connection.from.nib.id + "-" + connection.from.node.id;
          if ((_ref5 = outbound_connections_by_nib[key]) == null) {
            outbound_connections_by_nib[key] = {
              connections: []
            };
          }
          outbound_connections_by_nib[key].connections.push(connection);
        }
        for (id in outbound_connections_by_nib) {
          grouping = outbound_connections_by_nib[id];
          new_nib = this.add_output();
          _ref6 = grouping.connections;
          for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
            connection = _ref6[_o];
            new Connection({
              scope: this,
              from: clone_endpoint(connection.from),
              to: {
                node: this,
                nib: new_nib
              }
            });
            connection.from = {
              node: new_node,
              nib: new_nib
            };
          }
        }
        return new_node;
      };

      return Graph;

    })(Subroutine);
    find_value = function(text, type, collection) {
      var id, thing;
      if (collection == null) {
        collection = all_definitions;
      }
      for (id in collection) {
        thing = collection[id];
        if (thing instanceof type) {
          if (thing.text === text) {
            return thing;
          }
        }
      }
    };
    make_value = function(scope, position, user_input, force_string) {
      var implementation, value;
      if (force_string == null) {
        force_string = false;
      }
      implementation = user_input instanceof Definition ? user_input : force_string ? (find_value(user_input, StringLiteral)) || new StringLiteral({
        text: user_input
      }) : (value = eval_expression(user_input), value instanceof String ? (find_value(value, StringLiteral)) || new StringLiteral({
        text: value
      }) : (find_value(user_input, JSONLiteral)) || new JSONLiteral({
        text: user_input
      }));
      return new Value({
        scope: scope,
        position: position,
        implementation: implementation
      });
    };
    Literal = (function(_super) {

      __extends(Literal, _super);

      function Literal() {
        Literal.__super__.constructor.apply(this, arguments);
      }

      return Literal;

    })(Definition);
    JSONLiteral = (function(_super) {

      __extends(JSONLiteral, _super);

      function JSONLiteral() {
        return JSONLiteral.__super__.constructor.apply(this, arguments);
      }

      JSONLiteral.prototype.type = 'json_literal';

      JSONLiteral.prototype.evaluate = function() {
        return eval_expression(this.text);
      };

      return JSONLiteral;

    })(Literal);
    StringLiteral = (function(_super) {

      __extends(StringLiteral, _super);

      function StringLiteral() {
        return StringLiteral.__super__.constructor.apply(this, arguments);
      }

      StringLiteral.prototype.type = 'string_literal';

      StringLiteral.prototype.evaluate = function() {
        return this.text;
      };

      return StringLiteral;

    })(Literal);
    definition_classes = [Graph, JavaScript, JSONLiteral, StringLiteral];
    definition_class_map = make_index_map(definition_classes, 'name');
    /* NODE TYPES
    */

    Node = (function(_super) {

      __extends(Node, _super);

      function Node(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.scope = _ref.scope, this.id = _ref.id, this.position = _ref.position, this.implementation = _ref.implementation;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        this.scope.nodes.push(this);
      }

      Node.prototype.get_inputs = function() {
        return this.implementation.inputs;
      };

      Node.prototype.get_outputs = function() {
        return this.implementation.outputs;
      };

      Node.prototype["delete"] = function() {
        this.scope.delete_node_connections(this);
        return this.scope.remove_node(this);
      };

      Node.prototype.toJSON = function() {
        return _.extend(Node.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          implementation_id: this.implementation.id,
          position: this.position
        });
      };

      Node.prototype.clone = function(new_scope) {
        var data, new_node, old_id;
        data = JSON.parse(JSON.stringify(this));
        old_id = data.id;
        data.id = UUID();
        new_node = resurrect_node(new_scope, data);
        new_node.old_id = old_id;
        return new_node;
      };

      return Node;

    })(Type);
    Call = (function(_super) {

      __extends(Call, _super);

      function Call() {
        return Call.__super__.constructor.apply(this, arguments);
      }

      Call.prototype.type = 'call';

      Call.prototype.virtual_inputs = function(the_scope) {
        var input, input_values, _fn, _i, _len, _ref,
          _this = this;
        input_values = [];
        _ref = this.implementation.inputs;
        _fn = function(input) {
          return input_values.push(_.memoize(function() {
            return the_scope.subroutine.evaluate_connection(the_scope, _this, input);
          }));
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          _fn(input);
        }
        return input_values;
      };

      Call.prototype.evaluate = function(the_scope, output_nib) {
        var input_values;
        input_values = this.virtual_inputs(the_scope);
        return this.implementation.invoke(output_nib, input_values, the_scope, this);
      };

      Call.prototype.get_inputs = function() {
        return this.implementation.inputs;
      };

      Call.prototype.get_outputs = function() {
        return this.implementation.outputs;
      };

      /*
              subroutines_referenced: ->
                  # TODO: UPDATE
                  return [] unless @implementation instanceof Graph
                  results = []
                  for input in @inputs
                      parent = input.get_connection()?.connection.output.parent
                      if parent
                          results.push parent.id if parent.type is 'function'
                          resuts = results.concat parent.subroutines_referenced()
                  return results
      */


      return Call;

    })(Node);
    Value = (function(_super) {

      __extends(Value, _super);

      function Value() {
        Value.__super__.constructor.apply(this, arguments);
        this.outputs = [value_output_nib];
      }

      Value.prototype.type = 'value';

      Value.prototype.evaluate = function() {
        return this.implementation.evaluate();
      };

      Value.prototype.subroutines_referenced = function() {
        return [];
      };

      Value.prototype.get_inputs = function() {
        return [];
      };

      Value.prototype.get_outputs = function() {
        return this.outputs;
      };

      return Value;

    })(Node);
    UnknownNode = (function(_super) {

      __extends(UnknownNode, _super);

      function UnknownNode(position, type, text, id) {
        this.position = position;
        this.id = id;
        this.type = 'unknown';
        this.text = "Unknown " + type + ": " + text;
        this.inputs = [];
        this.outputs = [];
        UnknownNode.__super__.constructor.apply(this, arguments);
      }

      return UnknownNode;

    })(Node);
    node_classes = [Call, Value];
    node_class_map = make_index_map(node_classes, 'name');
    /* OTHER TYPES
    */

    Nib = (function() {

      function Nib(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.scope = _ref.scope, this.text = _ref.text, this.id = _ref.id, this.index = _ref.index;
        if (this.id !== null) {
          if ((_ref1 = this.id) == null) {
            this.id = UUID();
          }
        }
      }

      Nib.prototype.initialize = function() {
        return this;
      };

      Nib.prototype.toJSON = function() {
        return {
          text: this.text,
          id: this.id
        };
      };

      return Nib;

    })();
    Input = (function(_super) {

      __extends(Input, _super);

      function Input() {
        return Input.__super__.constructor.apply(this, arguments);
      }

      return Input;

    })(Nib);
    Output = (function(_super) {

      __extends(Output, _super);

      function Output() {
        return Output.__super__.constructor.apply(this, arguments);
      }

      return Output;

    })(Nib);
    Connection = (function() {

      function Connection(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.scope = _ref.scope, this.from = _ref.from, this.to = _ref.to, this.id = _ref.id;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        this.scope.connections.push(this);
        if (!(this.from instanceof Object && this.to instanceof Object)) {
          throw "WTF";
        }
      }

      Connection.prototype.toJSON = function() {
        return {
          from: {
            nib: this.from.nib.id,
            node: this.from.node.id
          },
          to: {
            nib: this.to.nib.id,
            node: this.to.node.id
          }
        };
      };

      return Connection;

    })();
    value_output_nib = new Output({
      scope: null,
      id: null,
      index: 0
    });
    is_input = function(it) {
      var is_input_class;
      is_input_class = it.nib instanceof Input;
      if (it.node instanceof Graph) {
        return is_input_class;
      } else {
        return !is_input_class;
      }
    };
    make_connection = function(scope, _arg) {
      var from, from_input, to, to_input, _ref;
      from = _arg.from, to = _arg.to;
      from_input = is_input(from);
      to_input = is_input(to);
      if (!((from_input && !to_input) || (to_input && !from_input))) {
        return;
      }
      if (to_input) {
        _ref = [to, from], from = _ref[0], to = _ref[1];
      }
      scope.delete_connections('to', to.node, to.nib);
      return new Connection({
        scope: scope,
        from: from,
        to: to
      });
    };
    find_nib_uses = function(nib, direction) {
      var connection, id, subroutine, uses, _i, _len, _ref;
      if (direction == null) {
        direction = 'to';
      }
      uses = {};
      for (id in all_definitions) {
        subroutine = all_definitions[id];
        if (!(subroutine instanceof Graph)) {
          continue;
        }
        _ref = subroutine.connections;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          connection = _ref[_i];
          if (connection[direction].nib === nib) {
            uses[subroutine.id] = subroutine;
          }
        }
      }
      return uses;
    };
    dissociate_exception = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        return setTimeout(function() {
          throw exception;
        });
      }
    };
    execute = function(routine) {
      try {
        return alert(JSON.stringify(routine()));
      } catch (exception) {
        if (exception instanceof RuntimeException) {
          return alert("Error: " + exception.message);
        } else {
          throw exception;
        }
      }
    };
    ignore_if_disconnected = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        if (!(exception instanceof NotConnected)) {
          throw exception;
        }
      }
    };
    eval_expression = function(expression) {
      return eval("(" + expression + ")");
    };
    start_saving = function() {
      return setInterval(save_state, 500);
    };
    save_state = function() {
      var state;
      state = {
        definitions: _.values(all_definitions),
        schema_version: schema_version
      };
      return localStorage.state = JSON.stringify(state);
    };
    load_state = function(data) {
      var builtin, builtin_data, definition_data, graph, id, implementation_pass, instance, second_pass, subroutine, subroutine_data, subroutines, the_class, transform_definition_data, transform_nib_data, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      switch (data.schema_version) {
        case 1:
          subroutines = {};
          second_pass = [];
          transform_nib_data = function(nib_texts) {
            var index, text, _i, _len, _results;
            _results = [];
            for (index = _i = 0, _len = nib_texts.length; _i < _len; index = ++_i) {
              text = nib_texts[index];
              _results.push({
                text: text,
                index: index
              });
            }
            return _results;
          };
          transform_definition_data = function(definition_data) {
            definition_data.inputs = transform_nib_data(definition_data.inputs);
            definition_data.outputs = transform_nib_data(definition_data.outputs);
            return definition_data.text = definition_data.name;
          };
          _ref = data.builtins;
          for (id in _ref) {
            builtin_data = _ref[id];
            transform_definition_data(builtin_data);
            builtin = new JavaScript(builtin_data);
            subroutines[builtin.id] = builtin;
          }
          _ref1 = data.subroutines;
          for (id in _ref1) {
            subroutine_data = _ref1[id];
            transform_definition_data(subroutine_data);
            subroutine_data.text = subroutine_data.name;
            subroutine = new Graph(subroutine_data);
            subroutines[subroutine.id] = subroutine;
            second_pass.push(subroutine);
          }
          for (_i = 0, _len = second_pass.length; _i < _len; _i++) {
            subroutine = second_pass[_i];
            load_implementation(subroutine, data.subroutines[subroutine.id], subroutines);
          }
          return all_definitions;
        case 2:
          implementation_pass = [];
          _ref2 = data.definitions;
          for (id in _ref2) {
            definition_data = _ref2[id];
            the_class = definition_class_map[definition_data.type];
            instance = new the_class(definition_data);
            if (instance instanceof Graph) {
              implementation_pass.push({
                graph: instance,
                data: definition_data
              });
            }
          }
          for (_j = 0, _len1 = implementation_pass.length; _j < _len1; _j++) {
            _ref3 = implementation_pass[_j], graph = _ref3.graph, data = _ref3.data;
            load_implementation_v2(graph, data);
          }
          return all_definitions;
      }
    };
    resurrect_node = function(scope, node_data) {
      var implementation, node, node_class, position;
      node_class = node_class_map[node_data.type];
      position = V(node_data.position);
      implementation = all_definitions[node_data.implementation_id];
      return node = new node_class({
        scope: scope,
        position: position,
        implementation: implementation,
        id: node_data.id
      });
    };
    load_implementation_v2 = function(graph, data) {
      var connection_data, from_nib, from_node, get_nib, get_node, node_data, to_nib, to_node, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node_data = _ref[_i];
        resurrect_node(graph, node_data);
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection_data = _ref1[_j];
        get_node = function(direction) {
          var id;
          id = connection_data[direction].node;
          if (id === graph.id) {
            return graph;
          } else {
            return _.find(graph.nodes, function(node) {
              return node.id === id;
            });
          }
        };
        from_node = get_node('from');
        to_node = get_node('to');
        get_nib = function(node, nibs, direction) {
          if (node instanceof Value) {
            return nibs[0];
          } else {
            return _.find(nibs, function(nib) {
              return nib.id === connection_data[direction].nib;
            });
          }
        };
        from_nib = get_nib(from_node, from_node.get_outputs(), 'from');
        to_nib = get_nib(to_node, to_node.get_inputs(), 'to');
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          scope: graph,
          from: {
            node: from_node,
            nib: from_nib
          },
          to: {
            node: to_node,
            nib: to_nib
          }
        }));
      }
      return _results;
    };
    load_implementation = function(subroutine, data, subroutines) {
      var connection_data, found_value, from_nib, from_node, get_node, implementation, node, position, to_nib, to_node, value, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        position = V(node.position);
        if (node.type === 'literal') {
          implementation = 'implementation_id' in node ? subroutines[node.implementation_id] : (found_value = find_value(node.text, JSONLiteral, subroutines), found_value ? found_value : (value = new JSONLiteral({
            text: node.text
          }), subroutines[value.id] = value, value));
          new Value({
            scope: subroutine,
            position: position,
            implementation: implementation,
            id: node.id
          });
        } else {
          implementation = subroutines[node.implementation_id];
          if (implementation) {
            new Call({
              scope: subroutine,
              position: position,
              implementation: implementation,
              id: node.id
            });
          } else {
            new UnknownNode(position, node.type, node.text, node.id);
          }
        }
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection_data = _ref1[_j];
        get_node = function(nib) {
          if (nib.parent_id === subroutine.id) {
            return subroutine;
          } else {
            return _.find(subroutine.nodes, function(node) {
              return node.id === nib.parent_id;
            });
          }
        };
        from_node = get_node(connection_data.output);
        to_node = get_node(connection_data.input);
        from_nib = from_node.get_outputs()[connection_data.output.index];
        to_nib = to_node.get_inputs()[connection_data.input.index];
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          scope: subroutine,
          from: {
            node: from_node,
            nib: from_nib
          },
          to: {
            node: to_node,
            nib: to_nib
          }
        }));
      }
      return _results;
    };
    if (localStorage.state != null) {
      source_data = JSON.parse(localStorage.state);
    } else {
      source_data_deferred = $q.defer();
      source_data = source_data_deferred.promise;
      $http.get('examples.json').success(function(data) {
        return source_data_deferred.resolve(data);
      });
    }
    all_definitions = {};
    loaded = $q.defer();
    $q.when(source_data, function(source_data) {
      var id, obj, _ref;
      _ref = load_state(source_data);
      for (id in _ref) {
        obj = _ref[id];
        all_definitions[id] = obj;
      }
      loaded.resolve(true);
      if (window.location.search !== '?debug') {
        return start_saving();
      }
    });
    return {
      make_connection: make_connection,
      find_nib_uses: find_nib_uses,
      make_value: make_value,
      loaded: loaded.promise,
      RuntimeException: RuntimeException,
      Exit: Exit,
      InputError: InputError,
      NotConnected: NotConnected,
      NotImplemented: NotImplemented,
      BuiltinSyntaxError: CodeSyntaxError,
      JavaScript: JavaScript,
      Graph: Graph,
      UnknownNode: UnknownNode,
      Call: Call,
      Value: Value,
      Literal: Literal,
      Input: Input,
      Output: Output,
      subroutines: all_definitions,
      Subroutine: Subroutine
    };
  });

}).call(this);
