// Generated by CoffeeScript 1.3.3
(function() {
  var module,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  module = angular.module('vislang');

  module.factory('interpreter', function($q, $http) {
    var Call, CodeSyntaxError, Connection, Definition, Exit, Graph, Input, InputError, JSONLiteral, JavaScript, Literal, Nib, Node, NotConnected, NotImplemented, Output, RuntimeException, StringLiteral, Subroutine, Type, UnknownNode, Value, all_definitions, definition_class_map, definition_classes, dissociate_exception, eval_expression, execute, find_nib_uses, find_value, ignore_if_disconnected, is_input, load_implementation, load_implementation_v2, load_state, loaded, make_connection, make_index_map, make_value, node_class_map, node_classes, save_state, schema_version, source_data, source_data_deferred, start_saving;
    schema_version = 2;
    make_index_map = function(objects, attribute) {
      var obj, result, _i, _len;
      result = {};
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        result[obj[attribute]] = obj;
      }
      return result;
    };
    /* EXCEPTION TYPES
    */

    RuntimeException = (function() {

      function RuntimeException(message) {
        this.message = message;
      }

      return RuntimeException;

    })();
    Exit = (function(_super) {

      __extends(Exit, _super);

      function Exit() {
        this.message = "Exit Signal";
      }

      return Exit;

    })(RuntimeException);
    InputError = (function(_super) {

      __extends(InputError, _super);

      function InputError() {
        this.message = "Cancelled execution due to lack of input";
      }

      return InputError;

    })(RuntimeException);
    NotConnected = (function(_super) {

      __extends(NotConnected, _super);

      function NotConnected() {
        this.message = "Something in the program is disconnected";
      }

      return NotConnected;

    })(RuntimeException);
    NotImplemented = (function(_super) {

      __extends(NotImplemented, _super);

      function NotImplemented(name) {
        this.name = name;
        this.message = "JavaScript \"" + this.name + "\" is not implemented";
      }

      return NotImplemented;

    })(RuntimeException);
    CodeSyntaxError = (function(_super) {

      __extends(CodeSyntaxError, _super);

      function CodeSyntaxError(name, exception) {
        this.name = name;
        this.exception = exception;
        this.message = "" + exception + " in builtin \"" + this.name + "\": ";
      }

      return CodeSyntaxError;

    })(RuntimeException);
    /* DEFINITION TYPES
    */

    Type = (function() {

      function Type() {}

      Type.prototype.toJSON = function() {
        return {
          type: this.constructor.name
        };
      };

      return Type;

    })();
    Definition = (function(_super) {

      __extends(Definition, _super);

      function Definition() {
        return Definition.__super__.constructor.apply(this, arguments);
      }

      Definition.prototype.toJSON = function() {
        return _.extend(Definition.__super__.toJSON.call(this), {
          id: this.id,
          text: this.text
        });
      };

      Definition.prototype.find_nib = function(id) {
        var nib, _i, _len, _ref;
        _ref = this.inputs.concat(this.outputs);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nib = _ref[_i];
          if (nib.id === id) {
            return nib;
          }
        }
      };

      return Definition;

    })(Type);
    Subroutine = (function(_super) {

      __extends(Subroutine, _super);

      function Subroutine() {
        return Subroutine.__super__.constructor.apply(this, arguments);
      }

      Subroutine.prototype.fromJSON = function(data) {
        var nib_data;
        all_definitions[this.id] = this;
        this.inputs = (function() {
          var _i, _len, _ref, _results;
          _ref = data.inputs;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            nib_data = _ref[_i];
            _results.push((new Input).fromJSON(nib_data, this));
          }
          return _results;
        }).call(this);
        this.outputs = (function() {
          var _i, _len, _ref, _results;
          _ref = data.outputs;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            nib_data = _ref[_i];
            _results.push((new Output).fromJSON(nib_data, this));
          }
          return _results;
        }).call(this);
        return this;
      };

      Subroutine.prototype.initialize = function() {
        /* Populate fields for a brand new instance.
        */
        this.id = UUID();
        all_definitions[this.id] = this;
        this.inputs = [];
        this.outputs = [];
        return this;
      };

      Subroutine.prototype.user_inputs = function() {
        var input, input_values, _fn, _i, _len, _ref;
        input_values = [];
        _ref = this.inputs;
        _fn = function(input) {
          var value;
          value = _.memoize(function() {
            var result;
            result = prompt("Provide a JSON value for input " + input.index + ": \"" + input.text + "\"");
            if (result === null) {
              throw new Exit("cancelled execution");
            }
            try {
              return JSON.parse(result);
            } catch (exception) {
              if (exception instanceof SyntaxError) {
                throw new InputError(result);
              } else {
                throw exception;
              }
            }
          });
          return input_values.push(value);
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          _fn(input);
        }
        return input_values;
      };

      Subroutine.prototype.run = function(nib) {
        var input_values,
          _this = this;
        input_values = this.user_inputs();
        try {
          return setTimeout(function() {
            return execute(function() {
              return _this.invoke(nib, input_values);
            });
          });
        } catch (exception) {
          if (exception instanceof InputError) {
            return alert("Invalid JSON: " + exception.message);
          } else {
            throw exception;
          }
        }
      };

      Subroutine.prototype.add_input = function() {
        return this.inputs.push((new Input).initialize());
      };

      Subroutine.prototype.add_output = function() {
        return this.outputs.push((new Output).initialize());
      };

      Subroutine.prototype.delete_input = function(nib) {
        return this.inputs.splice(nib.index, 1);
      };

      Subroutine.prototype.delete_output = function(nib) {
        return this.outputs.splice(nib.index, 1);
      };

      Subroutine.prototype.toJSON = function() {
        return _.extend(Subroutine.__super__.toJSON.call(this), {
          inputs: this.inputs,
          outputs: this.outputs
        });
      };

      return Subroutine;

    })(Definition);
    JavaScript = (function(_super) {

      __extends(JavaScript, _super);

      function JavaScript() {
        return JavaScript.__super__.constructor.apply(this, arguments);
      }

      JavaScript.prototype.type = 'javascript';

      JavaScript.prototype.fromJSON = function(data) {
        this.text = data.text, this.id = data.id, this.memo_implementation = data.memo_implementation, this.output_implementation = data.output_implementation;
        return JavaScript.__super__.fromJSON.call(this, data);
      };

      JavaScript.prototype.toJSON = function() {
        return _.extend(JavaScript.__super__.toJSON.call(this), {
          memo_implementation: this.memo_implementation,
          output_implementation: this.output_implementation
        });
      };

      JavaScript.prototype["export"] = function() {
        var builtins;
        builtins = {};
        builtins[this.id] = this;
        return {
          all_definitions: {},
          builtins: builtins,
          schema_version: schema_version
        };
      };

      JavaScript.prototype.invoke = function(output_nib, inputs, scope, node) {
        var args, memo_function, output_function;
        try {
          memo_function = eval_expression(this.memo_implementation);
          output_function = eval_expression(this.output_implementation);
        } catch (exception) {
          if (exception instanceof SyntaxError) {
            throw new CodeSyntaxError(this.text, exception);
          } else {
            throw exception;
          }
        }
        if (!output_function) {
          throw new NotImplemented(this.text);
        }
        args = inputs.concat([output_nib.index]);
        if (scope && memo_function && !(node.id in scope.memos)) {
          scope.memos[node.id] = memo_function.apply(null, args);
        }
        return output_function.apply(null, args.concat([scope != null ? scope.memos[node.id] : void 0]));
      };

      return JavaScript;

    })(Subroutine);
    Graph = (function(_super) {

      __extends(Graph, _super);

      Graph.prototype.type = 'graph';

      function Graph() {
        /* Initialize the bare minimum bits.
        Be sure to call fromJSON or initialize next.
        */
        this.nodes = {};
        this.connections = {};
      }

      Graph.prototype.fromJSON = function(data) {
        /* Populate from the persistence format
        */
        this.text = data.text, this.id = data.id;
        return Graph.__super__.fromJSON.call(this, data);
      };

      Graph.prototype.toJSON = function() {
        return _.extend(Graph.__super__.toJSON.call(this), {
          nodes: _.values(this.nodes),
          connections: _.values(this.connections)
        });
      };

      /* RUNNING
      */


      Graph.prototype.invoke = function(output_nib, inputs) {
        /* Evaluates an output in a fresh scope
        */

        var scope;
        scope = {
          subroutine: this,
          inputs: inputs,
          memos: {}
        };
        return this.evaluate_connection(scope, this, output_nib);
      };

      Graph.prototype.evaluate_connection = function(scope, to_node, to_nib) {
        /* This helper will follow a connection and evaluate whatever it finds
        */

        var connection, nib, node, _ref;
        connection = this.find_connection('to', to_node, to_nib);
        if (!connection) {
          throw new NotConnected;
        }
        _ref = connection.from, node = _ref.node, nib = _ref.nib;
        if (node instanceof Graph) {
          return scope.inputs[nib.index]();
        } else {
          return node.evaluate(scope, nib);
        }
      };

      Graph.prototype.find_connection = function(direction, node, nib) {
        /* Use this to determine how nodes are connected
        */

        var connection, id, _ref;
        _ref = this.connections;
        for (id in _ref) {
          connection = _ref[id];
          if (connection[direction].node.id === node.id && connection[direction].nib.id === nib.id) {
            return connection;
          }
        }
        return void 0;
      };

      Graph.prototype.delete_connections = function(direction, node, nib) {
        var connection, id, _ref, _results;
        _ref = this.connections;
        _results = [];
        for (id in _ref) {
          connection = _ref[id];
          if (connection[direction].node.id === node.id && connection[direction].nib.id === nib.id) {
            _results.push(delete this.connections[id]);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Graph.prototype["export"] = function() {
        var dependencies;
        dependencies = this.get_dependencies();
        dependencies.schema_version = schema_version;
        return dependencies;
      };

      Graph.prototype.delete_input = function(nib) {
        this.delete_connections('to', this, nib);
        return Graph.__super__.delete_input.call(this, nib);
      };

      Graph.prototype.delete_output = function(nib) {
        this.delete_connections('from', this, nib);
        return Graph.__super__.delete_output.call(this, nib);
      };

      /* probably outdated
      remove_node: (node) ->
          delete @nodes[node.id]
      
      add_node: (node) ->
          @nodes[node.id] = node
      
      remove_connection: (connection) ->
          delete @connections[connection.id]
      
      add_connection: (connection) ->
          @connections[connection.id] = connection
      
      get_dependencies: (dependencies={subroutines:{},builtins:{}}) ->
          # TODO: UPDATE
          dependencies.subroutines[@id] = @ if @id not of dependencies.subroutines
          for id, node of @nodes
              if node instanceof SubroutineApplication
                  child_dependencies = node.implementation.get_dependencies dependencies
                  _.extend dependencies.subroutines, child_dependencies.subroutines
                  _.extend dependencies.builtins, child_dependencies.builtins
              else if node instanceof BuiltinApplication
                  dependencies.builtins[@id] = node.implementation
          dependencies
      
      subroutines_referenced: ->
          # TODO: UPDATE
          # TODO: turn this into a cleanup function
          results = []
          for output in @outputs
              parent = output.get_connection()?.connection.output.parent
              if parent
                  results.push parent.id if parent.type is 'function'
                  resuts = results.concat parent.subroutines_referenced()
          return results
      
      build_adjacency_list: ->
          # clear prior data
          for id, node of @nodes
              node.adjacency_id = null
      
          adjacency_list = []
      
          # number and add self first
          adjacency_list.push
              node:@
              connections:[]
          @adjacency_id = 0
      
          # number all the connected nodes in a predictable way, and add them to the list
          input_queue = [].concat @outputs
          while input_queue.length > 0
              input = input_queue.shift()
              node = input.get_node()
              # NOTE: if node is a subroutine then we've reached ourselves again
              if node instanceof Node and node.adjacency_id is null
                  item_count = adjacency_list.push
                      node:node
                      connections:[]
                  node.adjacency_id = item_count - 1 # length is offset by 1 from index
                  input_queue = input_queue.concat node.inputs
      
          # record all the connections based on the consistent numbering scheme
          for item in adjacency_list
              nibs = if item.node instanceof Node then item.node.inputs else item.node.outputs
              for input, input_index in nibs
                  node = input.parent
                  item.connections[input_index] = node.adjacency_id
      
          adjacency_list
      */


      Graph.prototype.make_from = function(nodes) {
        /* Build a subroutine out of nodes in another subroutine.
        */

        var connection, contained_connections, id, in_connections, new_node, nib, node, old_scope, out_connections, _i, _len, _ref, _ref1, _ref2, _ref3, _results;
        old_scope = nodes[0].scope;
        in_connections = {};
        out_connections = {};
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          _ref = node.inputs;
          for (id in _ref) {
            nib = _ref[id];
            _ref1 = nib.connections;
            for (id in _ref1) {
              connection = _ref1[id];
              in_connections[connection.connection.id] = connection.connection;
            }
          }
          _ref2 = node.outputs;
          for (id in _ref2) {
            nib = _ref2[id];
            _ref3 = nib.connections;
            for (id in _ref3) {
              connection = _ref3[id];
              out_connections[connection.connection.id] = connection.connection;
            }
          }
        }
        contained_connections = {};
        for (id in in_connections) {
          connection = in_connections[id];
          if (connection.id in out_connections) {
            contained_connections[connection.id] = connection;
            delete in_connections[connection.id];
            delete out_connections[connection.id];
          }
        }
        for (id in contained_connections) {
          connection = contained_connections[id];
          old_scope.remove_connection(connection);
          this.add_connection(connection);
        }
        for (id in nodes) {
          node = nodes[id];
          old_scope.remove_node(node);
          this.add_node(node);
        }
        new_node = new SubroutineApplication(old_scope, V(0, 0), this);
        for (id in in_connections) {
          connection = in_connections[id];
          connection["delete"]();
        }
        _results = [];
        for (id in out_connections) {
          connection = out_connections[id];
          _results.push(connection["delete"]());
        }
        return _results;
      };

      return Graph;

    })(Subroutine);
    find_value = function(text, type, collection) {
      var id, thing;
      if (collection == null) {
        collection = all_definitions;
      }
      for (id in collection) {
        thing = collection[id];
        if (thing instanceof type) {
          if (thing.text === text) {
            return thing;
          }
        }
      }
    };
    make_value = function(scope, position, user_input, force_string) {
      var implementation, value;
      if (force_string == null) {
        force_string = false;
      }
      implementation = user_input instanceof Definition ? user_input : force_string ? (find_value(user_input, StringLiteral)) || new StringLiteral(user_input) : (value = eval_expression(user_input), value instanceof String ? (find_value(value, StringLiteral)) || new StringLiteral(value) : (find_value(user_input, JSONLiteral)) || new JSONLiteral(value));
      return new Value(scope, position, implementation);
    };
    Literal = (function(_super) {

      __extends(Literal, _super);

      function Literal() {}

      Literal.prototype.fromJSON = function(_arg) {
        var _ref;
        this.text = _arg.text, this.id = _arg.id;
        if ((_ref = this.id) == null) {
          this.id = UUID();
        }
        all_definitions[this.id] = this;
        this.inputs = [];
        this.outputs = [(new Output).initialize(this.id)];
        return this;
      };

      return Literal;

    })(Definition);
    JSONLiteral = (function(_super) {

      __extends(JSONLiteral, _super);

      function JSONLiteral() {
        return JSONLiteral.__super__.constructor.apply(this, arguments);
      }

      JSONLiteral.prototype.type = 'json_literal';

      JSONLiteral.prototype.evaluate = function() {
        return eval_expression(this.text);
      };

      return JSONLiteral;

    })(Literal);
    StringLiteral = (function(_super) {

      __extends(StringLiteral, _super);

      function StringLiteral() {
        return StringLiteral.__super__.constructor.apply(this, arguments);
      }

      StringLiteral.prototype.type = 'string_literal';

      StringLiteral.prototype.evaluate = function() {
        return this.text;
      };

      return StringLiteral;

    })(Literal);
    definition_classes = [Graph, JavaScript, JSONLiteral, StringLiteral];
    definition_class_map = make_index_map(definition_classes, 'name');
    /* NODE TYPES
    */

    Node = (function(_super) {

      __extends(Node, _super);

      function Node() {
        this.scope.nodes[this.id] = this;
      }

      Node.prototype.get_inputs = function() {
        return this.implementation.inputs;
      };

      Node.prototype.get_outputs = function() {
        return this.implementation.outputs;
      };

      Node.prototype["delete"] = function() {
        var nib, _i, _len, _ref, _results;
        delete this.scope.nodes[this.id];
        _ref = this.get_nibs();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nib = _ref[_i];
          _results.push(nib.delete_connections());
        }
        return _results;
      };

      Node.prototype.toJSON = function() {
        return _.extend(Node.__super__.toJSON.call(this), {
          id: this.id,
          implementation_id: this.implementation.id,
          position: this.position
        });
      };

      return Node;

    })(Type);
    Call = (function(_super) {

      __extends(Call, _super);

      Call.prototype.type = 'call';

      function Call(scope, position, implementation, id) {
        this.scope = scope;
        this.position = position;
        this.implementation = implementation;
        this.id = id != null ? id : UUID();
        Call.__super__.constructor.call(this);
      }

      Call.prototype.virtual_inputs = function(the_scope) {
        var input, input_values, _fn, _i, _len, _ref,
          _this = this;
        input_values = [];
        _ref = this.implementation.inputs;
        _fn = function(input) {
          return input_values.push(_.memoize(function() {
            return the_scope.subroutine.evaluate_connection(the_scope, _this, input);
          }));
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          _fn(input);
        }
        return input_values;
      };

      Call.prototype.evaluate = function(the_scope, output_nib) {
        var input_values;
        input_values = this.virtual_inputs(the_scope);
        return this.implementation.invoke(output_nib, input_values, the_scope, this);
      };

      /*
              subroutines_referenced: ->
                  # TODO: UPDATE
                  return [] unless @implementation instanceof Graph
                  results = []
                  for input in @inputs
                      parent = input.get_connection()?.connection.output.parent
                      if parent
                          results.push parent.id if parent.type is 'function'
                          resuts = results.concat parent.subroutines_referenced()
                  return results
      */


      return Call;

    })(Node);
    Value = (function(_super) {

      __extends(Value, _super);

      Value.prototype.type = 'value';

      function Value(scope, position, implementation, id) {
        this.scope = scope;
        this.position = position;
        this.implementation = implementation;
        this.id = id != null ? id : UUID();
        Value.__super__.constructor.call(this);
      }

      Value.prototype.evaluate = function() {
        return this.implementation.evaluate();
      };

      Value.prototype.subroutines_referenced = function() {
        return [];
      };

      return Value;

    })(Node);
    UnknownNode = (function(_super) {

      __extends(UnknownNode, _super);

      function UnknownNode(position, type, text, id) {
        this.position = position;
        this.id = id;
        this.type = 'unknown';
        this.text = "Unknown " + type + ": " + text;
        this.inputs = [];
        this.outputs = [];
        UnknownNode.__super__.constructor.call(this);
      }

      return UnknownNode;

    })(Node);
    node_classes = [Call, Value];
    node_class_map = make_index_map(node_classes, 'name');
    /* OTHER TYPES
    */

    Nib = (function() {

      function Nib() {}

      Nib.prototype.fromJSON = function(data, parent) {
        var _ref;
        this.parent = parent;
        this.text = data.text, this.index = data.index, this.id = data.id;
        if ((_ref = this.id) == null) {
          this.id = UUID();
        }
        return this;
      };

      Nib.prototype.initialize = function(id) {
        var _ref;
        this.id = id != null ? id : UUID();
        if ((_ref = this.id) == null) {
          this.id = UUID();
        }
        return this;
      };

      Nib.prototype.toJSON = function() {
        return {
          text: this.text,
          id: this.id
        };
      };

      return Nib;

    })();
    Input = (function(_super) {

      __extends(Input, _super);

      function Input() {
        return Input.__super__.constructor.apply(this, arguments);
      }

      return Input;

    })(Nib);
    Output = (function(_super) {

      __extends(Output, _super);

      function Output() {
        return Output.__super__.constructor.apply(this, arguments);
      }

      return Output;

    })(Nib);
    Connection = (function() {

      function Connection(scope, _arg, id) {
        this.scope = scope;
        this.from = _arg.from, this.to = _arg.to;
        this.id = id != null ? id : UUID();
        this.scope.connections[this.id] = this;
      }

      Connection.prototype.toJSON = function() {
        return {
          from: {
            nib: this.from.nib.id,
            node: this.from.node.id
          },
          to: {
            nib: this.to.nib.id,
            node: this.to.node.id
          }
        };
      };

      return Connection;

    })();
    is_input = function(it) {
      var is_input_class;
      is_input_class = it.nib instanceof Input;
      if (it.node instanceof Graph) {
        return is_input_class;
      } else {
        return !is_input_class;
      }
    };
    make_connection = function(scope, _arg) {
      var from, from_input, to, to_input, _ref;
      from = _arg.from, to = _arg.to;
      from_input = is_input(from);
      to_input = is_input(to);
      if (!((from_input && !to_input) || (to_input && !from_input))) {
        return;
      }
      if (to_input) {
        _ref = [to, from], from = _ref[0], to = _ref[1];
      }
      scope.delete_connections('to', to.node, to.nib);
      return new Connection(scope, {
        from: from,
        to: to
      });
    };
    find_nib_uses = function(nib, direction) {
      var connection, id, subroutine, uses, _ref;
      if (direction == null) {
        direction = 'to';
      }
      uses = {};
      for (id in all_definitions) {
        subroutine = all_definitions[id];
        _ref = subroutine.connections;
        for (id in _ref) {
          connection = _ref[id];
          if (connection[direction].nib === nib) {
            uses[subroutine.id] = subroutine;
          }
        }
      }
      return uses;
    };
    dissociate_exception = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        return setTimeout(function() {
          throw exception;
        });
      }
    };
    execute = function(routine) {
      try {
        return alert(JSON.stringify(routine()));
      } catch (exception) {
        if (exception instanceof RuntimeException) {
          return alert("Error: " + exception.message);
        } else {
          throw exception;
        }
      }
    };
    ignore_if_disconnected = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        if (!(exception instanceof NotConnected)) {
          throw exception;
        }
      }
    };
    eval_expression = function(expression) {
      return eval("(" + expression + ")");
    };
    start_saving = function() {
      return setInterval(save_state, 500);
    };
    save_state = function() {
      var state;
      state = {
        definitions: _.values(all_definitions),
        schema_version: schema_version
      };
      return localStorage.state = JSON.stringify(state);
    };
    load_state = function(data) {
      var builtin, builtin_data, definition_data, graph, id, implementation_pass, instance, second_pass, subroutine, subroutine_data, subroutines, the_class, transform_definition_data, transform_nib_data, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      switch (data.schema_version) {
        case 1:
          subroutines = {};
          second_pass = [];
          transform_nib_data = function(nib_texts) {
            var index, text, _i, _len, _results;
            _results = [];
            for (index = _i = 0, _len = nib_texts.length; _i < _len; index = ++_i) {
              text = nib_texts[index];
              _results.push({
                text: text,
                index: index
              });
            }
            return _results;
          };
          transform_definition_data = function(definition_data) {
            definition_data.inputs = transform_nib_data(definition_data.inputs);
            definition_data.outputs = transform_nib_data(definition_data.outputs);
            return definition_data.text = definition_data.name;
          };
          _ref = data.builtins;
          for (id in _ref) {
            builtin_data = _ref[id];
            transform_definition_data(builtin_data);
            builtin = (new JavaScript).fromJSON(builtin_data);
            subroutines[builtin.id] = builtin;
          }
          _ref1 = data.subroutines;
          for (id in _ref1) {
            subroutine_data = _ref1[id];
            transform_definition_data(subroutine_data);
            subroutine_data.text = subroutine_data.name;
            subroutine = (new Graph).fromJSON(subroutine_data);
            subroutines[subroutine.id] = subroutine;
            second_pass.push(subroutine);
          }
          for (_i = 0, _len = second_pass.length; _i < _len; _i++) {
            subroutine = second_pass[_i];
            load_implementation(subroutine, data.subroutines[subroutine.id], subroutines);
          }
          return all_definitions;
        case 2:
          implementation_pass = [];
          _ref2 = data.definitions;
          for (id in _ref2) {
            definition_data = _ref2[id];
            the_class = definition_class_map[definition_data.type];
            instance = (new the_class).fromJSON(definition_data);
            if (instance instanceof Graph) {
              implementation_pass.push({
                graph: instance,
                data: definition_data
              });
            }
          }
          for (_j = 0, _len1 = implementation_pass.length; _j < _len1; _j++) {
            _ref3 = implementation_pass[_j], graph = _ref3.graph, data = _ref3.data;
            load_implementation_v2(graph, data);
          }
          return all_definitions;
      }
    };
    load_implementation_v2 = function(graph, data) {
      var connection_data, from_nib, from_node, get_nib, get_node, implementation, node, node_class, node_data, position, to_nib, to_node, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node_data = _ref[_i];
        node_class = node_class_map[node_data.type];
        position = V(node_data.position);
        implementation = all_definitions[node_data.implementation_id];
        node = new node_class(graph, position, implementation, node_data.id);
        if (implementation == null) {
          console.log('what');
          console.log('what');
        }
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection_data = _ref1[_j];
        get_node = function(direction) {
          var id;
          id = connection_data[direction].node;
          if (id === graph.id) {
            return graph;
          } else {
            return graph.nodes[id];
          }
        };
        from_node = get_node('from');
        to_node = get_node('to');
        get_nib = function(node, direction) {
          var nib;
          implementation = node instanceof Definition ? node : node.implementation;
          nib = implementation.find_nib(connection_data[direction].nib);
          if (nib == null) {
            console.log('what');
            console.log('what');
          }
          return nib;
        };
        from_nib = get_nib(from_node, 'from');
        to_nib = get_nib(to_node, 'to');
        _results.push(new Connection(graph, {
          from: {
            node: from_node,
            nib: from_nib
          },
          to: {
            node: to_node,
            nib: to_nib
          }
        }, connection_data.id));
      }
      return _results;
    };
    load_implementation = function(subroutine, data, subroutines) {
      var connection, found_value, from, get_connector, implementation, input, node, output, position, to, value, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        position = V(node.position);
        if (node.type === 'literal') {
          implementation = 'implementation_id' in node ? subroutines[node.implementation_id] : (found_value = find_value(node.text, JSONLiteral, subroutines), found_value ? found_value : (value = (new JSONLiteral).fromJSON({
            text: node.text
          }), subroutines[value.id] = value, value));
          new Value(subroutine, position, implementation, node.id);
        } else {
          implementation = subroutines[node.implementation_id];
          if (implementation) {
            new Call(subroutine, position, implementation, node.id);
          } else {
            new UnknownNode(position, node.type, node.text, node.id);
          }
        }
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection = _ref1[_j];
        /* legacy bullshit
        */

        get_connector = function(nib) {
          if (nib.parent_id === subroutine.id) {
            return subroutine;
          } else {
            return subroutine.nodes[nib.parent_id];
          }
        };
        from = get_connector(connection.input);
        to = get_connector(connection.output);
        input = from instanceof Definition ? from.outputs[connection.input.index] : from.implementation.inputs[connection.input.index];
        output = to instanceof Definition ? to.inputs[connection.output.index] : to.implementation.outputs[connection.output.index];
        if (!input) {
          console.log(subroutine.text);
          console.log(subroutine.text);
        }
        if (!output) {
          console.log(subroutine.text);
          console.log(subroutine.text);
        }
        _results.push(new Connection(subroutine, {
          from: {
            node: to,
            nib: output
          },
          to: {
            node: from,
            nib: input
          }
        }, connection.id));
        /*
        
                    # input/output reversal.  TODO: clean up subroutine implementation to avoid this
                    source_connector = if source instanceof Node then source.outputs else source.inputs
                    sink_connector = if sink instanceof Node then sink.inputs else sink.outputs
        
                    if connection.output.index >= source_connector.length or connection.input.index >= sink_connector.length
                        console.log "Oh no, trying to make an invalid connection"
                    else
                        source_connector[connection.output.index].connect sink_connector[connection.input.index]
        */

      }
      return _results;
    };
    if (localStorage.state != null) {
      source_data = JSON.parse(localStorage.state);
    } else {
      source_data_deferred = $q.defer();
      source_data = source_data_deferred.promise;
      $http.get('examples.json').success(function(data) {
        return source_data_deferred.resolve(data);
      });
    }
    all_definitions = {};
    loaded = $q.defer();
    $q.when(source_data, function(source_data) {
      var id, obj, _ref;
      _ref = load_state(source_data);
      for (id in _ref) {
        obj = _ref[id];
        all_definitions[id] = obj;
      }
      loaded.resolve(true);
      return start_saving();
    });
    return {
      make_connection: make_connection,
      find_nib_uses: find_nib_uses,
      make_value: make_value,
      loaded: loaded.promise,
      RuntimeException: RuntimeException,
      Exit: Exit,
      InputError: InputError,
      NotConnected: NotConnected,
      NotImplemented: NotImplemented,
      BuiltinSyntaxError: CodeSyntaxError,
      JavaScript: JavaScript,
      Graph: Graph,
      UnknownNode: UnknownNode,
      Call: Call,
      Value: Value,
      Literal: Literal,
      Input: Input,
      Output: Output,
      subroutines: all_definitions
    };
  });

}).call(this);
