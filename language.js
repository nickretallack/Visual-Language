// Generated by CoffeeScript 1.3.1
var Builtin, BuiltinApplication, BuiltinSyntaxError, Connection, Exit, FunctionApplication, Input, InputError, Literal, LiteralValue, Nib, Node, NotConnected, NotImplemented, Output, RuntimeException, SubRoutine, SubroutineApplication, UnknownNode, all_builtins, all_subroutines, boxes, current_scope, load_implementation, load_state, node_registry, schema_version, should_animate, system_arrow,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

schema_version = 1;

boxes = {};

node_registry = {};

all_subroutines = {};

all_builtins = {};

current_scope = null;

system_arrow = null;

should_animate = false;

/* MODELS
*/


RuntimeException = (function() {

  RuntimeException.name = 'RuntimeException';

  function RuntimeException(message) {
    this.message = message;
  }

  return RuntimeException;

})();

Exit = (function(_super) {

  __extends(Exit, _super);

  Exit.name = 'Exit';

  function Exit() {
    this.message = "Exit Signal";
  }

  return Exit;

})(RuntimeException);

InputError = (function(_super) {

  __extends(InputError, _super);

  InputError.name = 'InputError';

  function InputError() {
    this.message = "Cancelled execution due to lack of input";
  }

  return InputError;

})(RuntimeException);

NotConnected = (function(_super) {

  __extends(NotConnected, _super);

  NotConnected.name = 'NotConnected';

  function NotConnected() {
    this.message = "Something in the program is disconnected";
  }

  return NotConnected;

})(RuntimeException);

NotImplemented = (function(_super) {

  __extends(NotImplemented, _super);

  NotImplemented.name = 'NotImplemented';

  function NotImplemented(name) {
    this.name = name;
    this.message = "Builtin \"" + this.name + "\" is not implemented";
  }

  return NotImplemented;

})(RuntimeException);

BuiltinSyntaxError = (function(_super) {

  __extends(BuiltinSyntaxError, _super);

  BuiltinSyntaxError.name = 'BuiltinSyntaxError';

  function BuiltinSyntaxError(name, exception) {
    this.name = name;
    this.exception = exception;
    this.message = "" + exception + " in builtin \"" + this.name + "\": ";
  }

  return BuiltinSyntaxError;

})(RuntimeException);

Builtin = (function() {

  Builtin.name = 'Builtin';

  function Builtin(_arg) {
    this.name = _arg.name, this.output_implementation = _arg.output_implementation, this.memo_implementation = _arg.memo_implementation, this.inputs = _arg.inputs, this.outputs = _arg.outputs, this.id = _arg.id;
    if (this.memo_implementation == null) {
      this.memo_implementation = null;
    }
    if (this.inputs == null) {
      this.inputs = [];
    }
    if (this.outputs == null) {
      this.outputs = ['OUT'];
    }
    if (this.id == null) {
      this.id = UUID();
    }
    all_builtins[this.id] = this;
  }

  Builtin.prototype.type = 'builtin';

  Builtin.prototype.toJSON = function() {
    return {
      id: this.id,
      name: this.name,
      inputs: this.inputs,
      outputs: this.outputs,
      memo_implementation: this.memo_implementation,
      output_implementation: this.output_implementation
    };
  };

  Builtin.prototype["export"] = function() {
    var builtins;
    builtins = {};
    builtins[this.id] = this;
    return {
      subroutines: {},
      builtins: builtins,
      schema_version: schema_version
    };
  };

  return Builtin;

})();

/*
class SubroutineView
    constructor:(@subroutine, @graphics) ->
        for node in @subroutine.nodes
*/


SubRoutine = (function() {

  SubRoutine.name = 'SubRoutine';

  function SubRoutine(name, inputs, outputs, id) {
    var index, text;
    this.name = name != null ? name : '';
    if (inputs == null) {
      inputs = [];
    }
    if (outputs == null) {
      outputs = [];
    }
    this.id = id != null ? id : UUID();
    node_registry[this.id] = this;
    if (!outputs.length) {
      outputs = ['OUT'];
    }
    this.inputs = (function() {
      var _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = inputs.length; _i < _len; index = ++_i) {
        text = inputs[index];
        _results.push(new Output(this, text, index, inputs.length - 1));
      }
      return _results;
    }).call(this);
    this.outputs = (function() {
      var _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = outputs.length; _i < _len; index = ++_i) {
        text = outputs[index];
        _results.push(new Input(this, text, index, outputs.length - 1));
      }
      return _results;
    }).call(this);
    this.nodes = {};
    this.connections = {};
    all_subroutines[this.id] = this;
  }

  SubRoutine.prototype.type = 'subroutine';

  SubRoutine.prototype.toJSON = function() {
    return {
      id: this.id,
      name: this.name,
      nodes: _.values(this.nodes),
      connections: _.values(this.connections),
      inputs: this.get_inputs(),
      outputs: this.get_outputs()
    };
  };

  SubRoutine.prototype.invoke = function(index, inputs) {
    var output, the_scope, _ref;
    the_scope = {
      subroutine: this,
      inputs: inputs,
      memos: {}
    };
    output = (_ref = this.outputs[index].get_connection()) != null ? _ref.connection.output : void 0;
    if (!output) {
      throw new NotConnected;
    }
    if (output.parent instanceof SubRoutine) {
      return inputs[output.index]();
    } else if (output.parent instanceof Node) {
      return output.parent.evaluation(the_scope, output.index);
    }
  };

  SubRoutine.prototype.get_inputs = function() {
    var input, _i, _len, _ref, _results;
    _ref = this.inputs;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      input = _ref[_i];
      _results.push(input.text);
    }
    return _results;
  };

  SubRoutine.prototype.get_outputs = function() {
    var output, _i, _len, _ref, _results;
    _ref = this.outputs;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      output = _ref[_i];
      _results.push(output.text);
    }
    return _results;
  };

  SubRoutine.prototype.run = function(output_index, input_values) {
    var _this = this;
    return execute(function() {
      return _this.invoke(output_index, input_values);
    });
  };

  SubRoutine.prototype["export"] = function() {
    var dependencies;
    dependencies = this.get_dependencies();
    dependencies.schema_version = schema_version;
    return dependencies;
  };

  SubRoutine.prototype.get_dependencies = function(dependencies) {
    var child_dependencies, id, node, _ref;
    if (dependencies == null) {
      dependencies = {
        subroutines: {},
        builtins: {}
      };
    }
    if (!(this.id in dependencies.subroutines)) {
      dependencies.subroutines[this.id] = this;
    }
    _ref = this.nodes;
    for (id in _ref) {
      node = _ref[id];
      if (node instanceof SubroutineApplication) {
        child_dependencies = node.implementation.get_dependencies(dependencies);
        _.extend(dependencies.subroutines, child_dependencies.subroutines);
        _.extend(dependencies.builtins, child_dependencies.builtins);
      } else if (node instanceof BuiltinApplication) {
        dependencies.builtins[this.id] = node.implementation;
      }
    }
    return dependencies;
  };

  SubRoutine.prototype.subroutines_referenced = function() {
    var output, parent, results, resuts, _i, _len, _ref, _ref1;
    results = [];
    _ref = this.outputs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      output = _ref[_i];
      parent = (_ref1 = output.get_connection()) != null ? _ref1.connection.output.parent : void 0;
      if (parent) {
        if (parent.type === 'function') {
          results.push(parent.id);
        }
        resuts = results.concat(parent.subroutines_referenced());
      }
    }
    return results;
  };

  SubRoutine.prototype.build_adjacency_list = function() {
    var adjacency_list, id, input, input_index, input_queue, item, item_count, nibs, node, _i, _j, _len, _len1, _ref;
    _ref = this.nodes;
    for (id in _ref) {
      node = _ref[id];
      node.adjacency_id = null;
    }
    adjacency_list = [];
    adjacency_list.push({
      node: this,
      connections: []
    });
    this.adjacency_id = 0;
    input_queue = [].concat(this.outputs);
    while (input_queue.length > 0) {
      input = input_queue.shift();
      node = input.get_node();
      if (node instanceof Node && node.adjacency_id === null) {
        item_count = adjacency_list.push({
          node: node,
          connections: []
        });
        node.adjacency_id = item_count - 1;
        input_queue = input_queue.concat(node.inputs);
      }
    }
    for (_i = 0, _len = adjacency_list.length; _i < _len; _i++) {
      item = adjacency_list[_i];
      nibs = item.node instanceof Node ? item.node.inputs : item.node.outputs;
      for (input_index = _j = 0, _len1 = nibs.length; _j < _len1; input_index = ++_j) {
        input = nibs[input_index];
        node = input.get_node();
        item.connections[input_index] = node.adjacency_id;
      }
    }
    return adjacency_list;
  };

  SubRoutine.prototype.remove_node = function(node) {
    this.view.remove(node.view);
    return delete this.nodes[node.id];
  };

  SubRoutine.prototype.add_node = function(node) {
    this.view.add(node.view);
    return this.nodes[node.id] = node;
  };

  SubRoutine.prototype.remove_connection = function(connection) {
    this.view.remove(connection.view);
    return delete this.connections[connection.id];
  };

  SubRoutine.prototype.add_connection = function(connection) {
    this.view.add(connection.view);
    return this.connections[connection.id] = connection;
  };

  return SubRoutine;

})();

Node = (function() {

  Node.name = 'Node';

  function Node() {
    node_registry[this.id] = this;
    this.scope = current_scope;
    this.scope.nodes[this.id] = this;
  }

  Node.prototype.set_position = function(position) {
    this.position = position;
  };

  Node.prototype.get_nibs = function() {
    return this.inputs.concat(this.outputs);
  };

  Node.prototype["delete"] = function() {
    var nib, _i, _len, _ref, _results;
    delete this.scope.nodes[this.id];
    _ref = this.get_nibs();
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      nib = _ref[_i];
      _results.push(nib.delete_connections());
    }
    return _results;
  };

  Node.prototype.toJSON = function() {
    return {
      position: this.position,
      text: this.text,
      id: this.id,
      type: this.type
    };
  };

  return Node;

})();

FunctionApplication = (function(_super) {

  __extends(FunctionApplication, _super);

  FunctionApplication.name = 'FunctionApplication';

  function FunctionApplication(_arg) {
    var index, inputs, name, outputs, text;
    name = _arg.name, inputs = _arg.inputs, outputs = _arg.outputs;
    this.text = name;
    FunctionApplication.__super__.constructor.call(this);
    this.inputs = (function() {
      var _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = inputs.length; _i < _len; index = ++_i) {
        text = inputs[index];
        _results.push(new Input(this, text, index, inputs.length - 1));
      }
      return _results;
    }).call(this);
    this.outputs = (function() {
      var _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = outputs.length; _i < _len; index = ++_i) {
        text = outputs[index];
        _results.push(new Output(this, text, index, outputs.length - 1));
      }
      return _results;
    }).call(this);
  }

  FunctionApplication.prototype.evaluation = function(the_scope, output_index) {};

  FunctionApplication.prototype.toJSON = function() {
    var json;
    json = FunctionApplication.__super__.toJSON.call(this);
    json.implementation_id = this.implementation.id;
    return json;
  };

  FunctionApplication.prototype.virtual_inputs = function(the_scope) {
    var input, input_values, _fn, _i, _len, _ref;
    input_values = [];
    _ref = this.inputs;
    _fn = function(input) {
      return input_values.push(_.memoize(function() {
        var output, _ref1;
        output = (_ref1 = input.get_connection()) != null ? _ref1.connection.output : void 0;
        if (!output) {
          throw new NotConnected;
        }
        if (output.parent instanceof SubRoutine) {
          return the_scope.inputs[output.index]();
        } else if (output.parent instanceof Node) {
          return output.parent.evaluation(the_scope, output.index);
        }
      }));
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      input = _ref[_i];
      _fn(input);
    }
    return input_values;
  };

  return FunctionApplication;

})(Node);

UnknownNode = (function(_super) {

  __extends(UnknownNode, _super);

  UnknownNode.name = 'UnknownNode';

  function UnknownNode(position, type, text, id) {
    this.position = position;
    this.id = id;
    this.type = 'unknown';
    this.text = "Unknown " + type + ": " + text;
    this.inputs = [];
    this.outputs = [];
    UnknownNode.__super__.constructor.call(this);
  }

  return UnknownNode;

})(Node);

SubroutineApplication = (function(_super) {

  __extends(SubroutineApplication, _super);

  SubroutineApplication.name = 'SubroutineApplication';

  function SubroutineApplication(position, implementation, id) {
    this.position = position;
    this.implementation = implementation;
    this.id = id != null ? id : UUID();
    this.type = 'function';
    SubroutineApplication.__super__.constructor.call(this, {
      name: this.implementation.name,
      inputs: this.implementation.get_inputs(),
      outputs: this.implementation.get_outputs()
    });
  }

  SubroutineApplication.prototype.evaluation = function(the_scope, output_index) {
    var input_values;
    input_values = this.virtual_inputs(the_scope);
    return this.implementation.invoke(output_index, input_values);
  };

  SubroutineApplication.prototype.subroutines_referenced = function() {
    var input, parent, results, resuts, _i, _len, _ref, _ref1;
    results = [];
    _ref = this.inputs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      input = _ref[_i];
      parent = (_ref1 = input.get_connection()) != null ? _ref1.connection.output.parent : void 0;
      if (parent) {
        if (parent.type === 'function') {
          results.push(parent.id);
        }
        resuts = results.concat(parent.subroutines_referenced());
      }
    }
    return results;
  };

  return SubroutineApplication;

})(FunctionApplication);

BuiltinApplication = (function(_super) {

  __extends(BuiltinApplication, _super);

  BuiltinApplication.name = 'BuiltinApplication';

  function BuiltinApplication(position, implementation, id) {
    this.position = position;
    this.implementation = implementation;
    this.id = id != null ? id : UUID();
    this.type = 'builtin';
    BuiltinApplication.__super__.constructor.call(this, this.implementation);
  }

  BuiltinApplication.prototype.evaluation = function(the_scope, output_index) {
    var args, input_values, memo_function, output_function;
    input_values = this.virtual_inputs(the_scope);
    try {
      memo_function = eval_expression(this.implementation.memo_implementation);
      output_function = eval_expression(this.implementation.output_implementation);
    } catch (exception) {
      if (exception instanceof SyntaxError) {
        throw new BuiltinSyntaxError(this.text, exception);
      } else {
        throw exception;
      }
    }
    if (!output_function) {
      throw new NotImplemented(this.text);
    }
    args = input_values.concat([output_index]);
    if (memo_function && !(this.id in the_scope.memos)) {
      the_scope.memos[this.id] = memo_function.apply(null, args);
    }
    return output_function.apply(null, args.concat([the_scope.memos[this.id]]));
  };

  return BuiltinApplication;

})(FunctionApplication);

LiteralValue = (function() {

  LiteralValue.name = 'LiteralValue';

  function LiteralValue(text) {
    this.text = text;
  }

  LiteralValue.prototype.evaluation = function() {
    return eval_expression(this.text);
  };

  LiteralValue.prototype.type = 'literal';

  return LiteralValue;

})();

Literal = (function(_super) {

  __extends(Literal, _super);

  Literal.name = 'Literal';

  function Literal(position, value, id) {
    this.position = position;
    this.id = id != null ? id : UUID();
    this.type = 'literal';
    if (value instanceof SubRoutine) {
      this.implementation = value;
      this.text = value.name;
    } else {
      this.implementation = new LiteralValue(value);
      this.text = value;
    }
    Literal.__super__.constructor.call(this);
    this.inputs = [];
    this.outputs = [new Output(this, '')];
  }

  Literal.prototype.evaluation = function() {
    return this.implementation.evaluation();
  };

  Literal.prototype.toJSON = function() {
    var json;
    json = Literal.__super__.toJSON.call(this);
    if (this.implementation instanceof SubRoutine) {
      json.implementation_id = this.implementation.id;
    }
    return json;
  };

  Literal.prototype.subroutines_referenced = function() {
    return [];
  };

  return Literal;

})(Node);

Nib = (function() {

  Nib.name = 'Nib';

  function Nib() {
    this.connections = {};
  }

  Nib.prototype.delete_connections = function() {
    var connection, id, _ref, _results;
    _ref = this.connections;
    _results = [];
    for (id in _ref) {
      connection = _ref[id];
      _results.push(connection.connection["delete"]());
    }
    return _results;
  };

  return Nib;

})();

Input = (function(_super) {

  __extends(Input, _super);

  Input.name = 'Input';

  function Input(parent, text, index, siblings) {
    this.parent = parent;
    this.text = text;
    this.index = index != null ? index : 0;
    this.siblings = siblings != null ? siblings : 0;
    Input.__super__.constructor.call(this);
  }

  Input.prototype._add_connection = function(connection, vertex) {
    var _ref;
    if ((_ref = this.get_connection()) != null) {
      _ref.connection["delete"]();
    }
    this.connections = {};
    return this.connections[connection.id] = {
      connection: connection,
      vertex: vertex
    };
  };

  Input.prototype.get_connection = function() {
    var connection, id, _ref;
    _ref = this.connections;
    for (id in _ref) {
      connection = _ref[id];
      return connection;
    }
  };

  Input.prototype.get_node = function() {
    var _ref;
    return (_ref = this.get_connection()) != null ? _ref.connection.output.parent : void 0;
  };

  Input.prototype.connect = function(output) {
    return new Connection(this, output);
  };

  return Input;

})(Nib);

Output = (function(_super) {

  __extends(Output, _super);

  Output.name = 'Output';

  function Output(parent, text, index, siblings) {
    this.parent = parent;
    this.text = text;
    this.index = index != null ? index : 0;
    this.siblings = siblings != null ? siblings : 0;
    Output.__super__.constructor.call(this);
  }

  Output.prototype._add_connection = function(connection, vertex) {
    return this.connections[connection.id] = {
      connection: connection,
      vertex: vertex
    };
  };

  Output.prototype.connect = function(input) {
    return new Connection(input, this);
  };

  return Output;

})(Nib);

Connection = (function() {

  Connection.name = 'Connection';

  function Connection(input, output, id) {
    this.input = input;
    this.output = output;
    this.id = id != null ? id : UUID();
    this.scope = current_scope;
    this.scope.connections[this.id] = this;
  }

  Connection.prototype.toJSON = function() {
    return {
      input: {
        index: this.input.index,
        parent_id: this.input.parent.id
      },
      output: {
        index: this.output.index,
        parent_id: this.output.parent.id
      }
    };
  };

  Connection.prototype["delete"] = function() {
    delete this.scope.connections[this.id];
    delete this.output.connections[this.id];
    return this.input.connections = {};
  };

  return Connection;

})();

load_state = function(data) {
  var builtin, builtin_data, builtins, id, subroutine, subroutine_data, subroutines, _ref, _ref1;
  subroutines = {};
  builtins = {};
  _ref = data.builtins;
  for (id in _ref) {
    builtin_data = _ref[id];
    builtin = new Builtin(builtin_data);
    builtins[builtin.id] = builtin;
  }
  _ref1 = data.subroutines;
  for (id in _ref1) {
    subroutine_data = _ref1[id];
    subroutine = new SubRoutine(subroutine_data.name, subroutine_data.inputs, subroutine_data.outputs, subroutine_data.id);
    subroutines[subroutine.id] = subroutine;
  }
  for (id in subroutines) {
    subroutine = subroutines[id];
    current_scope = subroutine;
    load_implementation(subroutine, data.subroutines[id]);
  }
  return {
    subroutines: subroutines,
    builtins: builtins
  };
};

load_implementation = function(subroutine, data) {
  var builtin, connection, node, position, sink, sink_connector, source, source_connector, value, _i, _j, _len, _len1, _ref, _ref1, _results;
  _ref = data.nodes;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    node = _ref[_i];
    position = V(node.position);
    if (node.type === 'function') {
      subroutine = all_subroutines[node.implementation_id];
      if (subroutine) {
        new SubroutineApplication(position, subroutine, node.id);
      } else {
        new UnknownNode(position, node.type, node.text, node.id);
      }
    } else if (node.type === 'builtin') {
      builtin = all_builtins[node.implementation_id];
      if (builtin) {
        new BuiltinApplication(position, builtin, node.id);
      } else {
        new UnknownNode(position, node.type, node.text, node.id);
      }
    } else if (node.type === 'literal') {
      if ('implementation_id' in node) {
        subroutine = all_subroutines[node.implementation_id];
        value = subroutine;
      } else {
        value = node.text;
      }
      new Literal(position, value, node.id);
    }
  }
  _ref1 = data.connections;
  _results = [];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    connection = _ref1[_j];
    source = node_registry[connection.output.parent_id];
    sink = node_registry[connection.input.parent_id];
    source_connector = source instanceof Node ? source.outputs : source.inputs;
    sink_connector = sink instanceof Node ? sink.inputs : sink.outputs;
    if (connection.output.index >= source_connector.length || connection.input.index >= sink_connector.length) {
      _results.push(console.log("Oh no, trying to make an invalid connection"));
    } else {
      _results.push(source_connector[connection.output.index].connect(sink_connector[connection.input.index]));
    }
  }
  return _results;
};
