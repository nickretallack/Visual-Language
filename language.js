// Generated by CoffeeScript 1.3.3
(function() {
  var module,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  module = angular.module('vislang');

  module.factory('interpreter', function($q, $http, $timeout, $rootScope) {
    var BaseType, BoundLambda, Call, Code, CodeSyntaxError, CoffeeScript, Connection, Definition, Exit, Graph, Input, InputError, JSON, JavaScript, Lambda, Literal, Nib, Node, NotConnected, NotImplemented, Output, Runtime, RuntimeException, Subroutine, Symbol, Text, Type, UnknownNode, Value, all_definitions, clone_endpoint, definition_class_map, definition_classes, dissociate_exception, eval_expression, execute, find_nib_uses, find_value, ignore_if_disconnected, is_input, last, load_implementation, load_implementation_v2, load_state, loaded, make_connection, make_index_map, make_value, node_class_map, node_classes, resurrect_node, save_state, schema_version, sequencer_input_nib, sequencer_output_nib, source_data, source_data_deferred, start_saving, value_output_nib;
    schema_version = 2;
    eval_expression = function(expression) {
      return eval("(" + expression + ")");
    };
    make_index_map = function(objects, attribute) {
      var obj, result, _i, _len;
      result = {};
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        result[obj[attribute]] = obj;
      }
      return result;
    };
    clone_endpoint = function(endpoint) {
      return {
        node: endpoint.node,
        nib: endpoint.nib
      };
    };
    last = function(list) {
      return list[list.length - 1];
    };
    /* EXCEPTION TYPES
    */

    RuntimeException = (function() {

      function RuntimeException(message) {
        this.message = message;
      }

      return RuntimeException;

    })();
    Exit = (function(_super) {

      __extends(Exit, _super);

      function Exit() {
        this.message = "Exit Signal";
      }

      return Exit;

    })(RuntimeException);
    InputError = (function(_super) {

      __extends(InputError, _super);

      function InputError() {
        this.message = "Cancelled execution due to lack of input";
      }

      return InputError;

    })(RuntimeException);
    NotConnected = (function(_super) {

      __extends(NotConnected, _super);

      function NotConnected() {
        this.message = "Something in the program is disconnected";
      }

      return NotConnected;

    })(RuntimeException);
    NotImplemented = (function(_super) {

      __extends(NotImplemented, _super);

      function NotImplemented(name) {
        this.name = name;
        this.message = "JavaScript \"" + this.name + "\" is not implemented";
      }

      return NotImplemented;

    })(RuntimeException);
    CodeSyntaxError = (function(_super) {

      __extends(CodeSyntaxError, _super);

      function CodeSyntaxError(name, exception) {
        this.name = name;
        this.exception = exception;
        this.message = "" + exception + " in builtin \"" + this.name + "\": ";
      }

      return CodeSyntaxError;

    })(RuntimeException);
    /* RUNTIME
    */

    Runtime = (function() {

      function Runtime(_arg) {
        this.graphics_element = (_arg != null ? _arg : {}).graphics_element;
        this.log_messages = [];
        this.event_handlers = [];
        this.timers = [];
        this.state = {};
      }

      Runtime.prototype.cleanup = function() {
        var handler, timer, _i, _j, _len, _len1, _ref, _ref1, _results;
        _ref = this.event_handlers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          handler = _ref[_i];
          handler.element.removeEventListener(handler.handler);
        }
        _ref1 = this.timers;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          timer = _ref1[_j];
          _results.push(clearTimeout(timer));
        }
        return _results;
      };

      Runtime.prototype.setInterval = function(handler, output_index, delay) {
        var handle, timer,
          _this = this;
        handle = function() {
          return $rootScope.$apply(function() {
            return handler.call([], output_index, _this);
          });
        };
        timer = setInterval(handle, delay);
        return this.timers.push(timer);
      };

      Runtime.prototype.addEventListener = function(type, handler_subroutine, element, output_index) {
        var handler,
          _this = this;
        if (output_index == null) {
          output_index = 0;
        }
        handler = function(event) {
          return $rootScope.$apply(function() {
            return handler_subroutine.call([event], output_index, _this);
          });
        };
        element.addEventListener(type, handler);
        return this.event_handlers.push({
          element: element,
          handler: handler
        });
      };

      Runtime.prototype.log = function(message) {
        this.log_messages.unshift(message);
        return console.log(message);
      };

      return Runtime;

    })();
    /* DEFINITION TYPES
    */

    BaseType = (function() {

      function BaseType() {}

      BaseType.prototype.toJSON = function() {
        return {
          type: this.constructor.name
        };
      };

      return BaseType;

    })();
    Definition = (function(_super) {

      __extends(Definition, _super);

      function Definition(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.id = _ref.id, this.text = _ref.text;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        all_definitions[this.id] = this;
      }

      Definition.prototype.fromJSON = function() {
        return this;
      };

      Definition.prototype.initialize = function() {
        return this;
      };

      Definition.prototype.toJSON = function() {
        return _.extend(Definition.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          text: this.text
        });
      };

      Definition.prototype.find_nib = function(id) {
        var nib, _i, _len, _ref;
        _ref = this.inputs.concat(this.outputs);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nib = _ref[_i];
          if (nib.id === id) {
            return nib;
          }
        }
      };

      Definition.prototype.get_call_inputs = function() {
        return this.inputs;
      };

      Definition.prototype.get_value_inputs = function() {
        return [];
      };

      Definition.prototype.find_uses = function() {
        var graph, id, _results;
        _results = [];
        for (id in all_definitions) {
          graph = all_definitions[id];
          if (graph instanceof Graph && graph.uses_definition(this)) {
            _results.push(graph);
          }
        }
        return _results;
      };

      return Definition;

    })(BaseType);
    Subroutine = (function(_super) {

      __extends(Subroutine, _super);

      function Subroutine(_arg) {
        var data, inputs, outputs, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        _ref = _arg != null ? _arg : {}, inputs = _ref.inputs, outputs = _ref.outputs, this.stateful = _ref.stateful;
        Subroutine.__super__.constructor.apply(this, arguments);
        this.inputs = [];
        this.outputs = [];
        _ref1 = inputs || [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          data = _ref1[_i];
          this.add_input(data);
        }
        _ref2 = outputs || [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          data = _ref2[_j];
          this.add_output(data);
        }
      }

      Subroutine.prototype.user_inputs = function() {
        var input, input_values, _fn, _i, _len, _ref;
        input_values = [];
        _ref = this.inputs;
        _fn = function(input) {
          var value;
          value = _.memoize(function() {
            var result;
            result = input.default_value ? input.default_value : prompt("Provide a JSON value for input " + input.index + ": \"" + input.text + "\"");
            if (result === null) {
              throw new Exit("cancelled execution");
            }
            try {
              return window.JSON.parse(result);
            } catch (exception) {
              if (exception instanceof SyntaxError) {
                throw new InputError(result);
              } else {
                throw exception;
              }
            }
          });
          return input_values.push(value);
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          _fn(input);
        }
        return input_values;
      };

      Subroutine.prototype.run = function(nib, runtime) {
        var input_values,
          _this = this;
        input_values = this.user_inputs();
        try {
          return $timeout(function() {
            return execute(runtime, function() {
              return _this.invoke(nib, input_values, null, null, runtime);
            });
          });
        } catch (exception) {
          if (exception instanceof InputError) {
            return runtime.log("Invalid JSON: " + exception.message);
          } else {
            throw exception;
          }
        }
      };

      Subroutine.prototype.call = function(inputs, output_index, runtime) {
        var input, nib, wrapped_inputs, _fn, _i, _len;
        if (output_index == null) {
          output_index = 0;
        }
        nib = this.outputs[output_index];
        wrapped_inputs = [];
        _fn = function(input) {
          return wrapped_inputs.push(function() {
            return input;
          });
        };
        for (_i = 0, _len = inputs.length; _i < _len; _i++) {
          input = inputs[_i];
          _fn(input);
        }
        return this.invoke(nib, wrapped_inputs, null, null, runtime);
      };

      Subroutine.prototype.delete_nib = function(nib, group) {
        var index, _i, _len, _ref, _results;
        this[group] = _.without(this[group], nib);
        _ref = this[group];
        _results = [];
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          nib = _ref[index];
          _results.push(nib.index = index);
        }
        return _results;
        /*
                    delete_index = @[group].indexOf nib
                    @[group].splice delete_index, 1
                    for index in [delete_index...@[group].length]
                        @[group][index].index -= 1
        */

      };

      Subroutine.prototype.add_nib = function(group, the_class, data) {
        var nib;
        if (data == null) {
          data = {};
        }
        nib = new the_class(_.extend(data, {
          index: this[group].length
        }));
        this[group].push(nib);
        return nib;
      };

      Subroutine.prototype.delete_input = function(nib) {
        return this.delete_nib(nib, 'inputs');
      };

      Subroutine.prototype.delete_output = function(nib) {
        return this.delete_nib(nib, 'outputs');
      };

      Subroutine.prototype.add_input = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('inputs', Input, data);
      };

      Subroutine.prototype.add_output = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('outputs', Output, data);
      };

      Subroutine.prototype.toJSON = function() {
        return _.extend(Subroutine.__super__.toJSON.apply(this, arguments), {
          inputs: this.inputs,
          outputs: this.outputs,
          stateful: this.stateful
        });
      };

      Subroutine.prototype.get_nib_type = function(type) {
        if (type === 'input') {
          return this.get_inputs();
        } else {
          return this.get_outputs();
        }
      };

      Subroutine.prototype.get_inputs = function() {
        return this.outputs;
      };

      Subroutine.prototype.get_outputs = function() {
        return this.inputs;
      };

      Subroutine.prototype.add_stateful_nib = function(nib, nibs) {
        if (!this.stateful) {
          return nibs;
        } else {
          return nibs.concat([nib]);
        }
      };

      Subroutine.prototype.get_call_inputs = function() {
        return this.add_stateful_nib(sequencer_input_nib, this.inputs);
      };

      Subroutine.prototype.get_call_outputs = function() {
        return this.add_stateful_nib(sequencer_output_nib, this.outputs);
      };

      Subroutine.prototype.evaluate = function() {
        return this;
      };

      return Subroutine;

    })(Definition);
    Code = (function(_super) {

      __extends(Code, _super);

      function Code(_arg) {
        var _ref;
        _ref = _arg != null ? _arg : {}, this.memo_implementation = _ref.memo_implementation, this.output_implementation = _ref.output_implementation;
        Code.__super__.constructor.apply(this, arguments);
      }

      Code.prototype.toJSON = function() {
        return _.extend(Code.__super__.toJSON.apply(this, arguments), {
          memo_implementation: this.memo_implementation,
          output_implementation: this.output_implementation
        });
      };

      Code.prototype.invoke = function(output_nib, inputs, scope, node, runtime) {
        var args, memo_function, output_function, stateful_input;
        if (this.stateful) {
          stateful_input = last(inputs);
          ignore_if_disconnected(stateful_input);
          inputs = inputs.slice(0, -1);
        }
        try {
          memo_function = this.eval_code(this.memo_implementation);
          output_function = this.eval_code(this.output_implementation);
        } catch (exception) {
          if (exception instanceof SyntaxError) {
            throw new CodeSyntaxError(this.text, exception);
          } else {
            throw exception;
          }
        }
        if (!output_function) {
          throw new NotImplemented(this.text);
        }
        args = inputs.concat([output_nib.index, runtime]);
        if (scope && memo_function && !(node.id in scope.memos)) {
          scope.memos[node.id] = memo_function.apply(null, args);
        }
        if (output_nib.id === 'stateful_output') {
          return;
        }
        return output_function.apply(null, args.concat([scope != null ? scope.memos[node.id] : void 0]));
      };

      return Code;

    })(Subroutine);
    CoffeeScript = (function(_super) {

      __extends(CoffeeScript, _super);

      function CoffeeScript() {
        return CoffeeScript.__super__.constructor.apply(this, arguments);
      }

      CoffeeScript.prototype.eval_code = function(code) {
        if (code) {
          return eval(window.CoffeeScript.compile(code, {
            bare: true
          }));
        }
      };

      return CoffeeScript;

    })(Code);
    JavaScript = (function(_super) {

      __extends(JavaScript, _super);

      function JavaScript() {
        return JavaScript.__super__.constructor.apply(this, arguments);
      }

      JavaScript.prototype.eval_code = eval_expression;

      return JavaScript;

    })(Code);
    Graph = (function(_super) {

      __extends(Graph, _super);

      function Graph() {
        Graph.__super__.constructor.apply(this, arguments);
        this.nodes = [];
        this.connections = [];
      }

      Graph.prototype.toJSON = function() {
        return _.extend(Graph.__super__.toJSON.apply(this, arguments), {
          nodes: this.nodes,
          connections: this.connections
        });
      };

      /* RUNNING
      */


      Graph.prototype.invoke = function(output_nib, inputs, parent_scope, node, runtime) {
        /* Evaluates an output in a fresh scope
        */

        var scope;
        scope = {
          subroutine: this,
          inputs: inputs,
          memos: {}
        };
        return this.evaluate_connection(scope, this, output_nib, runtime);
      };

      Graph.prototype.evaluate_connection = function(scope, to_node, to_nib, runtime) {
        /* This helper will follow a connection and evaluate whatever it finds
        */

        var connection, nib, node, _ref;
        connection = this.find_connection('to', to_node, to_nib);
        if (!connection) {
          throw new NotConnected("Missing connection in " + this.text + " to node " + (window.JSON.stringify(to_node)));
        }
        _ref = connection.from, node = _ref.node, nib = _ref.nib;
        if (node instanceof Graph) {
          return scope.inputs[nib.index]();
        } else {
          return node.evaluate(scope, nib, runtime);
        }
      };

      Graph.prototype.find_connection = function(direction, node, nib) {
        var connection, _i, _len, _ref;
        if (!((node != null) && (nib != null))) {
          console.log("what");
          console.log("what");
        }
        /* Use this to determine how nodes are connected
        */

        _ref = this.connections;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          connection = _ref[_i];
          if (connection[direction].node.id === node.id && connection[direction].nib.id === nib.id) {
            return connection;
          }
        }
        return void 0;
      };

      Graph.prototype.delete_connections = function(direction, node, nib) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection[direction].node === node && connection[direction].nib === nib;
        });
      };

      Graph.prototype.delete_node_connections = function(node) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection.from.node === node || connection.to.node === node;
        });
      };

      Graph.prototype.delete_nodes = function(nodes) {
        this.connections = _.reject(this.connections, function(connection) {
          var _ref, _ref1;
          return (_ref = connection.from.node, __indexOf.call(nodes, _ref) >= 0) || (_ref1 = connection.to.node, __indexOf.call(nodes, _ref1) >= 0);
        });
        return this.nodes = _.without.apply(_, [this.nodes].concat(__slice.call(nodes)));
      };

      Graph.prototype["export"] = function() {
        var dependencies;
        dependencies = this.get_dependencies();
        dependencies.schema_version = schema_version;
        return dependencies;
      };

      Graph.prototype.delete_input = function(nib) {
        this.delete_connections('to', this, nib);
        return Graph.__super__.delete_input.call(this, nib);
      };

      Graph.prototype.delete_output = function(nib) {
        this.delete_connections('from', this, nib);
        return Graph.__super__.delete_output.call(this, nib);
      };

      Graph.prototype.remove_node = function(node) {
        return this.nodes = _.without(this.nodes, node);
      };

      Graph.prototype.add_node = function(node) {
        node.graph = this;
        return this.nodes.push(node);
      };

      Graph.prototype.remove_connection = function(connection) {
        return this.connections = _.without(this.connections, connection);
      };

      Graph.prototype.add_connection = function(connection) {
        return this.connections.push(connection);
      };

      Graph.prototype.uses_definition = function(definition) {
        var node, _i, _len, _ref;
        _ref = this.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (node.implementation === definition) {
            return true;
          }
        }
      };

      /* probably outdated
      get_dependencies: (dependencies={subroutines:{},builtins:{}}) ->
          # TODO: UPDATE
          dependencies.subroutines[@id] = @ if @id not of dependencies.subroutines
          for id, node of @nodes
              if node instanceof SubroutineApplication
                  child_dependencies = node.implementation.get_dependencies dependencies
                  _.extend dependencies.subroutines, child_dependencies.subroutines
                  _.extend dependencies.builtins, child_dependencies.builtins
              else if node instanceof BuiltinApplication
                  dependencies.builtins[@id] = node.implementation
          dependencies
      
      subroutines_referenced: ->
          # TODO: UPDATE
          # TODO: turn this into a cleanup function
          results = []
          for output in @outputs
              parent = output.get_connection()?.connection.output.parent
              if parent
                  results.push parent.id if parent.type is 'function'
                  resuts = results.concat parent.subroutines_referenced()
          return results
      
      build_adjacency_list: ->
          # clear prior data
          for id, node of @nodes
              node.adjacency_id = null
      
          adjacency_list = []
      
          # number and add self first
          adjacency_list.push
              node:@
              connections:[]
          @adjacency_id = 0
      
          # number all the connected nodes in a predictable way, and add them to the list
          input_queue = [].concat @outputs
          while input_queue.length > 0
              input = input_queue.shift()
              node = input.get_node()
              # NOTE: if node is a subroutine then we've reached ourselves again
              if node instanceof Node and node.adjacency_id is null
                  item_count = adjacency_list.push
                      node:node
                      connections:[]
                  node.adjacency_id = item_count - 1 # length is offset by 1 from index
                  input_queue = input_queue.concat node.inputs
      
          # record all the connections based on the consistent numbering scheme
          for item in adjacency_list
              nibs = if item.node instanceof Node then item.node.inputs else item.node.outputs
              for input, input_index in nibs
                  node = input.parent
                  item.connections[input_index] = node.adjacency_id
      
          adjacency_list
      */


      Graph.prototype.bust_node = function(busting_node) {
        var beginning_connection, busting_scope, connection, inbound_connections, inner_connection, inner_connections, internal_connections, middle_connection, new_node, nib, node, node_mapping, outbound_connections, outer_connection, outer_connections, through_connections, translate_endpoint, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1,
          _this = this;
        this.remove_node(busting_node);
        busting_scope = busting_node.implementation;
        node_mapping = {};
        _ref = busting_scope.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          new_node = node.clone(this);
          node_mapping[node.id] = new_node;
        }
        translate_endpoint = function(endpoint) {
          return {
            node: node_mapping[endpoint.node.id],
            nib: endpoint.nib
          };
        };
        internal_connections = _.filter(busting_scope.connections, function(connection) {
          return connection.from.node !== busting_scope && connection.to.node !== busting_scope;
        });
        for (_j = 0, _len1 = internal_connections.length; _j < _len1; _j++) {
          connection = internal_connections[_j];
          new Connection({
            graph: this,
            from: translate_endpoint(connection.from),
            to: translate_endpoint(connection.to)
          });
        }
        inbound_connections = _.filter(this.connections, function(connection) {
          return connection.to.node === busting_node;
        });
        through_connections = [];
        for (_k = 0, _len2 = inbound_connections.length; _k < _len2; _k++) {
          connection = inbound_connections[_k];
          this.remove_connection(connection);
          nib = connection.to.nib;
          inner_connections = _.filter(busting_scope.connections, function(inner_connection) {
            return inner_connection.from.nib === nib && inner_connection.from.node === busting_scope;
          });
          for (_l = 0, _len3 = inner_connections.length; _l < _len3; _l++) {
            inner_connection = inner_connections[_l];
            if (inner_connection.to.node === busting_scope) {
              through_connections.push({
                beginning_connection: connection,
                middle_connection: inner_connection
              });
            } else {
              new Connection({
                graph: this,
                from: clone_endpoint(connection.from),
                to: translate_endpoint(inner_connection.to)
              });
            }
          }
        }
        for (_m = 0, _len4 = through_connections.length; _m < _len4; _m++) {
          _ref1 = through_connections[_m], beginning_connection = _ref1.beginning_connection, middle_connection = _ref1.middle_connection;
          nib = middle_connection.to.nib;
          outer_connections = _.filter(this.connections, function(outer_connection) {
            return outer_connection.from.nib === nib && outer_connection.from.node === busting_node;
          });
          for (_n = 0, _len5 = outer_connections.length; _n < _len5; _n++) {
            outer_connection = outer_connections[_n];
            outer_connection.from = clone_endpoint(beginning_connection.from);
          }
        }
        outbound_connections = _.filter(this.connections, function(connection) {
          return connection.from.node === busting_node;
        });
        for (_o = 0, _len6 = outbound_connections.length; _o < _len6; _o++) {
          connection = outbound_connections[_o];
          nib = connection.from.nib;
          inner_connection = _.find(busting_scope.connections, function(connection) {
            return connection.to.node === busting_scope && connection.to.nib === nib;
          });
          if (inner_connection) {
            connection.from = translate_endpoint(inner_connection.from);
          }
        }
        return _.values(node_mapping);
      };

      Graph.prototype.make_from = function(old_graph, nodes) {
        /* Build a subroutine out of nodes in another subroutine.
        */

        var connection, contained_connections, cross_threshhold, from_inside, group_connections, inbound_connections, new_node, node, outbound_connections, to_inside, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2,
          _this = this;
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          old_scope.remove_node(node);
          this.add_node(node);
        }
        new_node = new Call({
          graph: old_graph,
          position: V(0, 0),
          implementation: this
        });
        inbound_connections = [];
        outbound_connections = [];
        contained_connections = [];
        _ref = old_scope.connections;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          connection = _ref[_j];
          from_inside = (_ref1 = connection.from.node, __indexOf.call(nodes, _ref1) >= 0);
          to_inside = (_ref2 = connection.to.node, __indexOf.call(nodes, _ref2) >= 0);
          if (from_inside && to_inside) {
            contained_connections.push(connection);
          } else if (from_inside) {
            outbound_connections.push(connection);
          } else if (to_inside) {
            inbound_connections.push(connection);
          }
        }
        for (_k = 0, _len2 = contained_connections.length; _k < _len2; _k++) {
          connection = contained_connections[_k];
          old_scope.remove_connection(connection);
          this.add_connection(connection);
        }
        group_connections = function(connections) {
          var groups, key, _l, _len3, _ref3;
          groups = {};
          for (_l = 0, _len3 = connections.length; _l < _len3; _l++) {
            connection = connections[_l];
            key = "" + connection.from.nib.id + "-" + connection.from.node.id;
            if ((_ref3 = groups[key]) == null) {
              groups[key] = [];
            }
            groups[key].push(connection);
          }
          return _.values(groups);
        };
        cross_threshhold = function(connections, add_nib, direction, other_direction) {
          var data, group, new_nib, _l, _len3, _ref3, _results;
          _ref3 = group_connections(connections);
          _results = [];
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            group = _ref3[_l];
            new_nib = _this[add_nib]();
            _results.push((function() {
              var _len4, _m, _results1;
              _results1 = [];
              for (_m = 0, _len4 = group.length; _m < _len4; _m++) {
                connection = group[_m];
                data = {
                  graph: this
                };
                data[direction] = clone_endpoint(connection[direction]);
                data[other_direction] = {
                  node: this,
                  nib: new_nib
                };
                new Connection(data);
                _results1.push(connection[direction] = {
                  node: new_node,
                  nib: new_nib
                });
              }
              return _results1;
            }).call(_this));
          }
          return _results;
        };
        cross_threshhold(inbound_connections, 'add_input', 'to', 'from');
        cross_threshhold(outbound_connections, 'add_output', 'from', 'to');
        return new_node;
      };

      return Graph;

    })(Subroutine);
    BoundLambda = (function() {

      function BoundLambda(_arg) {
        this.node = _arg.node, this.parent_scope = _arg.parent_scope;
      }

      BoundLambda.prototype.invoke = function(output_nib, inputs, calling_scope, node, runtime) {
        var graph, scope;
        scope = {
          subroutine: this,
          inputs: inputs,
          memos: {}
        };
        graph = this.node.graph;
        return this.evaluate_connection(scope, this.node, output_nib, runtime);
      };

      BoundLambda.prototype.evaluate_connection = function(scope, to_node, to_nib, runtime) {
        " Check if it touches one of our inputs.  If not, do what the graph would do.\nEventually we'll have a real scope in here.";

        var connection, nib, node, _ref;
        connection = this.parent_scope.subroutine.find_connection('to', to_node, to_nib);
        if (!connection) {
          throw new NotConnected("Missing connection in " + this.text + " to node " + (window.JSON.stringify(to_node)));
        }
        _ref = connection.from, node = _ref.node, nib = _ref.nib;
        if (node === this.node) {
          return scope.inputs[nib.index]();
        } else if (node instanceof Graph) {
          return this.parent_scope.inputs[nib.index]();
        } else {
          return node.evaluate(scope, nib, runtime);
        }
      };

      return BoundLambda;

    })();
    Lambda = (function(_super) {

      __extends(Lambda, _super);

      function Lambda() {
        Lambda.__super__.constructor.apply(this, arguments);
        this.implementation_input = new Input({
          text: 'implementation',
          id: this.id
        });
      }

      Lambda.prototype.evaluate = function(scope, node) {
        return new BoundLambda({
          node: node,
          parent_scope: scope
        });
      };

      Lambda.prototype.invoke = function(output_nib, inputs, scope, node, runtime) {
        var implementation;
        implementation = inputs[0]();
        inputs = inputs.slice(1);
        return implementation.invoke(output_nib, inputs, null, null, runtime);
      };

      Lambda.prototype.get_call_inputs = function() {
        return [this.implementation_input].concat(this.inputs);
      };

      return Lambda;

    })(Graph);
    find_value = function(text, type, collection) {
      var id, thing;
      if (collection == null) {
        collection = all_definitions;
      }
      for (id in collection) {
        thing = collection[id];
        if (thing instanceof type) {
          if (!thing.text && thing.value === text) {
            return thing;
          }
        }
      }
    };
    make_value = function(graph, position, user_input, force_string) {
      var implementation, value;
      if (force_string == null) {
        force_string = false;
      }
      implementation = user_input instanceof Definition ? user_input : force_string ? (find_value(user_input, Text)) || new Text({
        value: user_input
      }) : (value = eval_expression(user_input), value instanceof String ? (find_value(value, Text)) || new Text({
        value: value
      }) : (find_value(user_input, JSON)) || new JSON({
        value: user_input
      }));
      return new Value({
        graph: graph,
        position: position,
        implementation: implementation
      });
    };
    Type = (function(_super) {

      __extends(Type, _super);

      function Type() {
        Type.__super__.constructor.apply(this, arguments);
        this.type_input = new Input({
          text: '',
          id: this.id
        });
      }

      Type.prototype.get_call_inputs = function() {
        return [this.type_input];
      };

      Type.prototype.get_value_inputs = function() {
        return this.inputs;
      };

      Type.prototype.get_call_outputs = function() {
        return this.inputs;
      };

      return Type;

    })(Subroutine);
    Symbol = (function(_super) {

      __extends(Symbol, _super);

      function Symbol() {
        return Symbol.__super__.constructor.apply(this, arguments);
      }

      Symbol.prototype.evaluate = function() {
        return this.id;
      };

      return Symbol;

    })(Definition);
    Literal = (function(_super) {

      __extends(Literal, _super);

      function Literal(_arg) {
        this.value = (_arg != null ? _arg : {}).value;
        Literal.__super__.constructor.apply(this, arguments);
      }

      Literal.prototype.toJSON = function() {
        return _.extend(Literal.__super__.toJSON.apply(this, arguments), {
          value: this.value
        });
      };

      return Literal;

    })(Definition);
    JSON = (function(_super) {

      __extends(JSON, _super);

      function JSON() {
        return JSON.__super__.constructor.apply(this, arguments);
      }

      JSON.prototype.evaluate = function() {
        return eval_expression(this.value);
      };

      return JSON;

    })(Literal);
    Text = (function(_super) {

      __extends(Text, _super);

      function Text() {
        return Text.__super__.constructor.apply(this, arguments);
      }

      Text.prototype.evaluate = function() {
        return this.value;
      };

      return Text;

    })(Literal);
    definition_classes = [Graph, JavaScript, CoffeeScript, JSON, Text, Symbol, Lambda, Type];
    definition_class_map = make_index_map(definition_classes, 'name');
    /* NODE TYPES
    */

    Node = (function(_super) {

      __extends(Node, _super);

      function Node(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.graph = _ref.graph, this.id = _ref.id, this.position = _ref.position, this.implementation = _ref.implementation;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        this.graph.nodes.push(this);
      }

      Node.prototype.get_nib_type = function(type) {
        if (type === 'input') {
          return this.get_inputs();
        } else {
          return this.get_outputs();
        }
      };

      Node.prototype["delete"] = function() {
        this.graph.delete_node_connections(this);
        return this.graph.remove_node(this);
      };

      Node.prototype.toJSON = function() {
        return _.extend(Node.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          implementation_id: this.implementation.id,
          position: this.position
        });
      };

      Node.prototype.clone = function(new_scope) {
        var data, new_node, old_id;
        data = window.JSON.parse(window.JSON.stringify(this));
        old_id = data.id;
        data.id = UUID();
        new_node = resurrect_node(new_scope, data);
        new_node.old_id = old_id;
        return new_node;
      };

      return Node;

    })(BaseType);
    Call = (function(_super) {

      __extends(Call, _super);

      function Call() {
        return Call.__super__.constructor.apply(this, arguments);
      }

      Call.prototype.virtual_inputs = function(the_scope, runtime) {
        var input, input_values, _fn, _i, _len, _ref,
          _this = this;
        input_values = [];
        _ref = this.get_inputs();
        _fn = function(input) {
          return input_values.push(_.memoize(function() {
            return the_scope.subroutine.evaluate_connection(the_scope, _this, input, runtime);
          }));
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          _fn(input);
        }
        return input_values;
      };

      Call.prototype.evaluate = function(the_scope, output_nib, runtime) {
        var input_values;
        input_values = this.virtual_inputs(the_scope, runtime);
        return this.implementation.invoke(output_nib, input_values, the_scope, this, runtime);
      };

      Call.prototype.get_inputs = function() {
        return this.implementation.get_call_inputs();
      };

      Call.prototype.get_outputs = function() {
        return this.implementation.get_call_outputs();
      };

      /*
              subroutines_referenced: ->
                  # TODO: UPDATE
                  return [] unless @implementation instanceof Graph
                  results = []
                  for input in @inputs
                      parent = input.get_connection()?.connection.output.parent
                      if parent
                          results.push parent.id if parent.type is 'function'
                          resuts = results.concat parent.subroutines_referenced()
                  return results
      */


      return Call;

    })(Node);
    Value = (function(_super) {

      __extends(Value, _super);

      function Value() {
        Value.__super__.constructor.apply(this, arguments);
        this.outputs = [value_output_nib];
      }

      Value.prototype.type = 'value';

      Value.prototype.evaluate = function(the_scope, output_nib, runtime) {
        return this.implementation.evaluate(the_scope, this);
      };

      Value.prototype.subroutines_referenced = function() {
        return [];
      };

      Value.prototype.get_inputs = function() {
        return this.implementation.get_value_inputs();
      };

      Value.prototype.get_outputs = function() {
        return this.outputs;
      };

      return Value;

    })(Node);
    UnknownNode = (function(_super) {

      __extends(UnknownNode, _super);

      function UnknownNode(position, type, text, id) {
        this.position = position;
        this.id = id;
        this.type = 'unknown';
        this.text = "Unknown " + type + ": " + text;
        this.inputs = [];
        this.outputs = [];
        UnknownNode.__super__.constructor.apply(this, arguments);
      }

      return UnknownNode;

    })(Node);
    node_classes = [Call, Value];
    node_class_map = make_index_map(node_classes, 'name');
    /* OTHER TYPES
    */

    Nib = (function() {

      function Nib(_arg) {
        var _ref, _ref1, _ref2;
        _ref = _arg != null ? _arg : {}, this.text = _ref.text, this.id = _ref.id, this.index = _ref.index, this.n_ary = _ref.n_ary, this.default_value = _ref.default_value;
        if (this.id !== null) {
          if ((_ref1 = this.id) == null) {
            this.id = UUID();
          }
        }
        if ((_ref2 = this.n_ary) == null) {
          this.n_ary = false;
        }
      }

      Nib.prototype.initialize = function() {
        return this;
      };

      Nib.prototype.toJSON = function() {
        return {
          text: this.text,
          id: this.id,
          n_ary: this.n_ary,
          default_value: this.default_value
        };
      };

      return Nib;

    })();
    Input = (function(_super) {

      __extends(Input, _super);

      function Input() {
        return Input.__super__.constructor.apply(this, arguments);
      }

      return Input;

    })(Nib);
    Output = (function(_super) {

      __extends(Output, _super);

      function Output() {
        return Output.__super__.constructor.apply(this, arguments);
      }

      return Output;

    })(Nib);
    Connection = (function() {

      function Connection(_arg) {
        var _base, _base1, _ref, _ref1, _ref2, _ref3;
        _ref = _arg != null ? _arg : {}, this.graph = _ref.graph, this.from = _ref.from, this.to = _ref.to, this.id = _ref.id;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        this.graph.connections.push(this);
        if ((_ref2 = (_base = this.to).index) == null) {
          _base.index = 0;
        }
        if ((_ref3 = (_base1 = this.from).index) == null) {
          _base1.index = 0;
        }
        if (!(this.from instanceof Object && this.to instanceof Object)) {
          throw "WTF";
        }
      }

      Connection.prototype.toJSON = function() {
        return {
          from: {
            nib: this.from.nib.id,
            node: this.from.node.id,
            index: this.from.node.index,
            internal: this.from.internal
          },
          to: {
            nib: this.to.nib.id,
            node: this.to.node.id,
            index: this.to.node.index,
            internal: this.to.internal
          }
        };
      };

      return Connection;

    })();
    value_output_nib = new Output({
      id: 'value_output',
      index: 0
    });
    sequencer_input_nib = new Input({
      id: 'sequencer_input',
      index: 0,
      text: ';'
    });
    sequencer_output_nib = new Output({
      id: 'sequencer_output',
      index: 0,
      text: ';'
    });
    is_input = function(it) {
      var is_input_class;
      is_input_class = it.nib instanceof Input;
      if (it.node instanceof Graph || (it.node instanceof Call && it.node.implementation instanceof Type) || it.internal) {
        return is_input_class;
      } else {
        return !is_input_class;
      }
    };
    make_connection = function(graph, _arg) {
      var connector, from, from_input, to, to_input, _i, _len, _ref, _ref1;
      from = _arg.from, to = _arg.to;
      _ref = [to, from];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        connector = _ref[_i];
        if (connector.node.implementation instanceof Lambda && connector.node instanceof Value && connector.nib !== value_output_nib) {
          connector.internal = true;
        }
      }
      from_input = is_input(from);
      to_input = is_input(to);
      if (!((from_input && !to_input) || (to_input && !from_input))) {
        return;
      }
      if (to_input) {
        _ref1 = [to, from], from = _ref1[0], to = _ref1[1];
      }
      graph.delete_connections('to', to.node, to.nib);
      return new Connection({
        graph: graph,
        from: from,
        to: to
      });
    };
    find_nib_uses = function(nib, direction) {
      var connection, id, subroutine, uses, _i, _len, _ref;
      if (direction == null) {
        direction = 'to';
      }
      uses = {};
      for (id in all_definitions) {
        subroutine = all_definitions[id];
        if (!(subroutine instanceof Graph)) {
          continue;
        }
        _ref = subroutine.connections;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          connection = _ref[_i];
          if (connection[direction].nib === nib) {
            uses[subroutine.id] = subroutine;
          }
        }
      }
      return uses;
    };
    dissociate_exception = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        return $timeout(function() {
          throw exception;
        });
      }
    };
    execute = function(runtime, routine) {
      try {
        return runtime.log(window.JSON.stringify(routine()));
      } catch (exception) {
        if (exception instanceof RuntimeException) {
          return runtime.log("Error: " + exception.message);
        } else {
          throw exception;
        }
      }
    };
    ignore_if_disconnected = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        if (!(exception instanceof NotConnected)) {
          throw exception;
        }
      }
    };
    start_saving = function() {
      return setInterval(save_state, 500);
    };
    save_state = function() {
      var state;
      state = {
        definitions: _.values(all_definitions),
        schema_version: schema_version
      };
      return localStorage.state = window.JSON.stringify(state);
    };
    load_state = function(data) {
      var builtin, builtin_data, definition_data, graph, id, implementation_pass, instance, second_pass, subroutine, subroutine_data, subroutines, the_class, transform_definition_data, transform_nib_data, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      switch (data.schema_version) {
        case 1:
          subroutines = {};
          second_pass = [];
          transform_nib_data = function(nib_texts) {
            var index, text, _i, _len, _results;
            _results = [];
            for (index = _i = 0, _len = nib_texts.length; _i < _len; index = ++_i) {
              text = nib_texts[index];
              _results.push({
                text: text,
                index: index
              });
            }
            return _results;
          };
          transform_definition_data = function(definition_data) {
            definition_data.inputs = transform_nib_data(definition_data.inputs);
            definition_data.outputs = transform_nib_data(definition_data.outputs);
            return definition_data.text = definition_data.name;
          };
          _ref = data.builtins;
          for (id in _ref) {
            builtin_data = _ref[id];
            transform_definition_data(builtin_data);
            builtin = new JavaScript(builtin_data);
            subroutines[builtin.id] = builtin;
          }
          _ref1 = data.subroutines;
          for (id in _ref1) {
            subroutine_data = _ref1[id];
            transform_definition_data(subroutine_data);
            subroutine_data.text = subroutine_data.name;
            subroutine = new Graph(subroutine_data);
            subroutines[subroutine.id] = subroutine;
            second_pass.push(subroutine);
          }
          for (_i = 0, _len = second_pass.length; _i < _len; _i++) {
            subroutine = second_pass[_i];
            load_implementation(subroutine, data.subroutines[subroutine.id], subroutines);
          }
          return all_definitions;
        case 2:
          implementation_pass = [];
          _ref2 = data.definitions;
          for (id in _ref2) {
            definition_data = _ref2[id];
            if (definition_data.type === 'JSONLiteral') {
              definition_data.type = 'JSON';
            } else if (definition_data.type === 'StringLiteral') {
              definition_data.type = 'Text';
            }
            if ((_ref3 = definition_data.type) === 'JSON' || _ref3 === 'Text') {
              if ((_ref4 = definition_data.value) == null) {
                definition_data.value = definition_data.text;
              }
              if (definition_data.value === definition_data.text) {
                delete definition_data.text;
              }
            }
            the_class = definition_class_map[definition_data.type];
            instance = new the_class(definition_data);
            if (instance instanceof Graph) {
              implementation_pass.push({
                graph: instance,
                data: definition_data
              });
            }
          }
          for (_j = 0, _len1 = implementation_pass.length; _j < _len1; _j++) {
            _ref5 = implementation_pass[_j], graph = _ref5.graph, data = _ref5.data;
            load_implementation_v2(graph, data);
          }
          return all_definitions;
      }
    };
    resurrect_node = function(graph, node_data) {
      var implementation, node, node_class, position;
      node_class = node_class_map[node_data.type];
      position = V(node_data.position);
      implementation = all_definitions[node_data.implementation_id];
      return node = new node_class({
        graph: graph,
        position: position,
        implementation: implementation,
        id: node_data.id
      });
    };
    load_implementation_v2 = function(graph, data) {
      var connection_data, from_nib, from_node, get_nib, get_node, node_data, to_nib, to_node, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node_data = _ref[_i];
        resurrect_node(graph, node_data);
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection_data = _ref1[_j];
        get_node = function(direction) {
          var id;
          id = connection_data[direction].node;
          if (id === graph.id) {
            return graph;
          } else {
            return _.find(graph.nodes, function(node) {
              return node.id === id;
            });
          }
        };
        from_node = get_node('from');
        to_node = get_node('to');
        get_nib = function(node, connector, nib_type) {
          var nibs;
          if (connector.internal) {
            nibs = node.implementation["get_" + nib_type]();
            return _.find(nibs, function(nib) {
              return nib.id === connector.nib;
            });
          } else {
            nibs = node["get_" + nib_type]();
            if (node instanceof Value) {
              return nibs[0];
            } else {
              return _.find(nibs, function(nib) {
                return nib.id === connector.nib;
              });
            }
          }
        };
        from_nib = get_nib(from_node, connection_data['from'], 'outputs');
        to_nib = get_nib(to_node, connection_data['to'], 'inputs');
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          graph: graph,
          from: {
            node: from_node,
            nib: from_nib,
            internal: connection_data.from.internal
          },
          to: {
            node: to_node,
            nib: to_nib,
            internal: connection_data.to.internal
          }
        }));
      }
      return _results;
    };
    load_implementation = function(subroutine, data, subroutines) {
      var connection_data, found_value, from_nib, from_node, get_node, implementation, node, position, to_nib, to_node, value, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        position = V(node.position);
        if (node.type === 'literal') {
          implementation = 'implementation_id' in node ? subroutines[node.implementation_id] : (found_value = find_value(node.text, JSON, subroutines), found_value ? found_value : (value = new JSON({
            text: node.text
          }), subroutines[value.id] = value, value));
          new Value({
            graph: subroutine,
            position: position,
            implementation: implementation,
            id: node.id
          });
        } else {
          implementation = subroutines[node.implementation_id];
          if (implementation) {
            new Call({
              graph: subroutine,
              position: position,
              implementation: implementation,
              id: node.id
            });
          } else {
            new UnknownNode(position, node.type, node.text, node.id);
          }
        }
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection_data = _ref1[_j];
        get_node = function(nib) {
          if (nib.parent_id === subroutine.id) {
            return subroutine;
          } else {
            return _.find(subroutine.nodes, function(node) {
              return node.id === nib.parent_id;
            });
          }
        };
        from_node = get_node(connection_data.output);
        to_node = get_node(connection_data.input);
        from_nib = from_node.get_outputs()[connection_data.output.index];
        to_nib = to_node.get_inputs()[connection_data.input.index];
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          graph: subroutine,
          from: {
            node: from_node,
            nib: from_nib
          },
          to: {
            node: to_node,
            nib: to_nib
          }
        }));
      }
      return _results;
    };
    if (localStorage.state != null) {
      source_data = window.JSON.parse(localStorage.state);
    } else {
      source_data_deferred = $q.defer();
      source_data = source_data_deferred.promise;
      $http.get('examples.json').success(function(data) {
        return source_data_deferred.resolve(data);
      });
    }
    all_definitions = {};
    loaded = $q.defer();
    $q.when(source_data, function(source_data) {
      var id, obj, _ref;
      _ref = load_state(source_data);
      for (id in _ref) {
        obj = _ref[id];
        all_definitions[id] = obj;
      }
      loaded.resolve(true);
      if (window.location.search !== '?debug') {
        return start_saving();
      }
    });
    return {
      make_connection: make_connection,
      find_nib_uses: find_nib_uses,
      make_value: make_value,
      loaded: loaded.promise,
      RuntimeException: RuntimeException,
      Exit: Exit,
      InputError: InputError,
      NotConnected: NotConnected,
      NotImplemented: NotImplemented,
      BuiltinSyntaxError: CodeSyntaxError,
      definition_types: definition_classes,
      Definition: Definition,
      Subroutine: Subroutine,
      Graph: Graph,
      Code: Code,
      JavaScript: JavaScript,
      CoffeeScript: CoffeeScript,
      Lambda: Lambda,
      Type: Type,
      Literal: Literal,
      JSON: JSON,
      Text: Text,
      Symbol: Symbol,
      Node: Node,
      Call: Call,
      Value: Value,
      Input: Input,
      Output: Output,
      Connection: Connection,
      subroutines: all_definitions,
      Runtime: Runtime
    };
  });

}).call(this);
