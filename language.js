// Generated by CoffeeScript 1.4.0
(function() {
  var module,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module = angular.module('vislang');

  module.factory('interpreter', function($q, $http, $timeout, $rootScope) {
    var BaseType, BoundLambda, Call, Code, CodeSyntaxError, CoffeeScript, Connection, Definition, Exit, Graph, Input, InputError, JSON, JavaScript, Lambda, Literal, Nib, Node, NotConnected, NotImplemented, Output, Runtime, RuntimeException, Subroutine, Symbol, Text, Type, UnknownNode, Value, all_definitions, clone_endpoint, definition_class_map, definition_classes, dissociate_exception, eval_expression, execute, find_nib_uses, find_value, ignore_if_disconnected, is_input, last, load_implementation, load_implementation_v2, load_state, loaded, make_connection, make_index_map, make_value, node_class_map, node_classes, resurrect_node, save_state, schema_version, sequencer_input_nib, sequencer_output_nib, source_data, source_data_deferred, start_saving, strongly_connected_components, tarjan, value_output_nib;
    schema_version = 2;
    eval_expression = function(expression) {
      return eval("(" + expression + ")");
    };
    make_index_map = function(objects, attribute) {
      var obj, result, _i, _len;
      result = {};
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        result[obj[attribute]] = obj;
      }
      return result;
    };
    clone_endpoint = function(endpoint) {
      return {
        node: endpoint.node,
        nib: endpoint.nib
      };
    };
    last = function(list) {
      return list[list.length - 1];
    };
    /* EXCEPTION TYPES
    */

    RuntimeException = (function() {

      function RuntimeException(message) {
        this.message = message;
      }

      return RuntimeException;

    })();
    Exit = (function(_super) {

      __extends(Exit, _super);

      function Exit() {
        this.message = "Exit Signal";
      }

      return Exit;

    })(RuntimeException);
    InputError = (function(_super) {

      __extends(InputError, _super);

      function InputError() {
        this.message = "Cancelled execution due to lack of input";
      }

      return InputError;

    })(RuntimeException);
    NotConnected = (function(_super) {

      __extends(NotConnected, _super);

      function NotConnected(message) {
        this.message = message != null ? message : "Something in the program is disconnected";
      }

      return NotConnected;

    })(RuntimeException);
    NotImplemented = (function(_super) {

      __extends(NotImplemented, _super);

      function NotImplemented(name) {
        this.name = name;
        this.message = "JavaScript \"" + this.name + "\" is not implemented";
      }

      return NotImplemented;

    })(RuntimeException);
    CodeSyntaxError = (function(_super) {

      __extends(CodeSyntaxError, _super);

      function CodeSyntaxError(name, exception) {
        this.name = name;
        this.exception = exception;
        this.message = "" + exception + " in builtin \"" + this.name + "\": ";
      }

      return CodeSyntaxError;

    })(RuntimeException);
    /* RUNTIME
    */

    Runtime = (function() {

      function Runtime(_arg) {
        this.graphics_element = (_arg != null ? _arg : {}).graphics_element;
        this.log_messages = [];
        this.event_handlers = [];
        this.timers = [];
        this.state = {};
      }

      Runtime.prototype.cleanup = function() {
        var handler, timer, _i, _j, _len, _len1, _ref, _ref1, _results;
        _ref = this.event_handlers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          handler = _ref[_i];
          handler.element.removeEventListener(handler.handler);
        }
        _ref1 = this.timers;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          timer = _ref1[_j];
          _results.push(clearTimeout(timer));
        }
        return _results;
      };

      Runtime.prototype.setInterval = function(handler, output_index, delay) {
        var handle, timer,
          _this = this;
        handle = function() {
          return $rootScope.$apply(function() {
            return handler.call([], output_index, _this);
          });
        };
        timer = setInterval(handle, delay);
        return this.timers.push(timer);
      };

      Runtime.prototype.addEventListener = function(type, handler_subroutine, element, output_index) {
        var handler,
          _this = this;
        if (output_index == null) {
          output_index = 0;
        }
        handler = function(event) {
          return $rootScope.$apply(function() {
            return handler_subroutine.call([event], output_index, _this);
          });
        };
        element.addEventListener(type, handler);
        return this.event_handlers.push({
          element: element,
          handler: handler
        });
      };

      Runtime.prototype.log = function(message) {
        this.log_messages.unshift(message);
        return console.log(message);
      };

      return Runtime;

    })();
    /* DEFINITION TYPES
    */

    BaseType = (function() {

      function BaseType() {}

      BaseType.prototype.toJSON = function() {
        return {
          type: this.constructor.name
        };
      };

      return BaseType;

    })();
    Definition = (function(_super) {

      __extends(Definition, _super);

      function Definition(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.id = _ref.id, this.text = _ref.text;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        all_definitions[this.id] = this;
      }

      Definition.prototype.fromJSON = function() {
        return this;
      };

      Definition.prototype.initialize = function() {
        return this;
      };

      Definition.prototype.toJSON = function() {
        return _.extend(Definition.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          text: this.text
        });
      };

      Definition.prototype.find_nib = function(id) {
        var nib, _i, _len, _ref;
        _ref = this.inputs.concat(this.outputs);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          nib = _ref[_i];
          if (nib.id === id) {
            return nib;
          }
        }
      };

      Definition.prototype.get_call_inputs = function() {
        return this.inputs;
      };

      Definition.prototype.get_value_inputs = function() {
        return [];
      };

      Definition.prototype.find_uses = function() {
        var graph, id, _results;
        _results = [];
        for (id in all_definitions) {
          graph = all_definitions[id];
          if (graph instanceof Graph && graph.uses_definition(this)) {
            _results.push(graph);
          }
        }
        return _results;
      };

      return Definition;

    })(BaseType);
    Subroutine = (function(_super) {

      __extends(Subroutine, _super);

      function Subroutine(_arg) {
        var data, inputs, outputs, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        _ref = _arg != null ? _arg : {}, inputs = _ref.inputs, outputs = _ref.outputs, this.stateful = _ref.stateful;
        Subroutine.__super__.constructor.apply(this, arguments);
        this.inputs = [];
        this.outputs = [];
        _ref1 = inputs || [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          data = _ref1[_i];
          this.add_input(data);
        }
        _ref2 = outputs || [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          data = _ref2[_j];
          this.add_output(data);
        }
      }

      Subroutine.prototype.user_inputs = function() {
        var input, results;
        results = (function() {
          var _i, _len, _ref, _results;
          _ref = this.inputs;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            input = _ref[_i];
            _results.push((function(input) {
              return _.memoize(function() {
                var input_name, result;
                result = input.default_value ? input.default_value : (input_name = input.text ? "\"" + input.text + "\"" : "(nameless)", prompt("Provide a JSON value for input " + input.index + ": " + input_name));
                if (result === null) {
                  throw new Exit("cancelled execution");
                }
                try {
                  return window.JSON.parse(result);
                } catch (exception) {
                  if (exception instanceof SyntaxError) {
                    throw new InputError(result);
                  } else {
                    throw exception;
                  }
                }
              });
            })(input));
          }
          return _results;
        }).call(this);
        results.push(function() {});
        return results;
      };

      Subroutine.prototype.run = function(nib, runtime) {
        var child_scope, scope,
          _this = this;
        child_scope = {};
        scope = {
          runtime: runtime,
          parent_scope: null,
          nodes: child_scope,
          output_values: {},
          input_value_generators: this.user_inputs()
        };
        try {
          return $timeout(function() {
            return execute(runtime, function() {
              return _this.invoke(scope, nib);
            });
          });
        } catch (exception) {
          if (excepition instanceof InputError) {
            return runtime.log("Invalid JSON: " + exception.message);
          } else {
            throw exception;
          }
        }
      };

      Subroutine.prototype.call = function(inputs, output_index, runtime) {
        var input, nib, wrapped_inputs, _fn, _i, _len;
        if (output_index == null) {
          output_index = 0;
        }
        nib = this.outputs[output_index];
        wrapped_inputs = [];
        _fn = function(input) {
          return wrapped_inputs.push(function() {
            return input;
          });
        };
        for (_i = 0, _len = inputs.length; _i < _len; _i++) {
          input = inputs[_i];
          _fn(input);
        }
        return this.invoke(nib, wrapped_inputs, null, null, runtime);
      };

      Subroutine.prototype.delete_nib = function(nib, group) {
        var index, _i, _len, _ref, _results;
        this[group] = _.without(this[group], nib);
        _ref = this[group];
        _results = [];
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          nib = _ref[index];
          _results.push(nib.index = index);
        }
        return _results;
        /*
                    delete_index = @[group].indexOf nib
                    @[group].splice delete_index, 1
                    for index in [delete_index...@[group].length]
                        @[group][index].index -= 1
        */

      };

      Subroutine.prototype.add_nib = function(group, the_class, data) {
        var nib;
        if (data == null) {
          data = {};
        }
        nib = new the_class(_.extend(data, {
          index: this[group].length
        }));
        this[group].push(nib);
        return nib;
      };

      Subroutine.prototype.delete_input = function(nib) {
        return this.delete_nib(nib, 'inputs');
      };

      Subroutine.prototype.delete_output = function(nib) {
        return this.delete_nib(nib, 'outputs');
      };

      Subroutine.prototype.add_input = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('inputs', Input, data);
      };

      Subroutine.prototype.add_output = function(data) {
        if (data == null) {
          data = {};
        }
        return this.add_nib('outputs', Output, data);
      };

      Subroutine.prototype.toJSON = function() {
        return _.extend(Subroutine.__super__.toJSON.apply(this, arguments), {
          inputs: this.inputs,
          outputs: this.outputs,
          stateful: this.stateful
        });
      };

      Subroutine.prototype.get_nib_type = function(type) {
        if (type === 'input') {
          return this.get_inputs();
        } else {
          return this.get_outputs();
        }
      };

      Subroutine.prototype.get_inputs = function() {
        return this.outputs;
      };

      Subroutine.prototype.get_outputs = function() {
        return this.inputs;
      };

      Subroutine.prototype.add_stateful_nib = function(nib, nibs) {
        if (!this.stateful) {
          return nibs;
        } else {
          return nibs.concat([nib]);
        }
      };

      Subroutine.prototype.get_call_inputs = function() {
        return this.add_stateful_nib(sequencer_input_nib, this.inputs);
      };

      Subroutine.prototype.get_call_outputs = function() {
        return this.add_stateful_nib(sequencer_output_nib, this.outputs);
      };

      Subroutine.prototype.evaluate = function() {
        return this;
      };

      return Subroutine;

    })(Definition);
    Code = (function(_super) {

      __extends(Code, _super);

      function Code(_arg) {
        this.output_implementation = (_arg != null ? _arg : {}).output_implementation;
        Code.__super__.constructor.apply(this, arguments);
      }

      Code.prototype.toJSON = function() {
        return _.extend(Code.__super__.toJSON.apply(this, arguments), {
          output_implementation: this.output_implementation
        });
      };

      Code.prototype.invoke = function(scope, output_nib, node) {
        var input_generators, meta, output_function, result, stateful_input;
        if (node == null) {
          node = {
            id: 0
          };
        }
        input_generators = scope.input_value_generators;
        if (this.stateful) {
          stateful_input = last(input_generators);
          input_generators = input_generators.slice(0, -1);
          ignore_if_disconnected(stateful_input);
        }
        meta = {
          runtime: scope.runtime,
          output_index: output_nib.index,
          inputs: input_generators,
          state: scope.nodes,
          is_sequencer: output_nib === sequencer_output_nib
        };
        try {
          output_function = this.eval_code(this.output_implementation);
        } catch (exception) {
          if (exception instanceof SyntaxError) {
            throw new CodeSyntaxError(this.text, exception);
          } else {
            throw exception;
          }
        }
        if (!output_function) {
          throw new NotImplemented(this.text);
        }
        try {
          result = output_function.apply(null, [meta].concat(__slice.call(input_generators)));
          if (!meta.is_sequencer) {
            return result;
          }
        } catch (exception) {
          if (exception instanceof TypeError) {
            throw new CodeSyntaxError(this.text, exception);
          } else {
            throw exception;
          }
        }
      };

      Code.prototype.get_content_id = function() {
        return {
          implementation: this.output_implementation,
          type: 'code',
          language: this.language,
          inputs: this.inputs.length,
          outputs: this.outputs.length
        };
      };

      return Code;

    })(Subroutine);
    CoffeeScript = (function(_super) {

      __extends(CoffeeScript, _super);

      function CoffeeScript() {
        return CoffeeScript.__super__.constructor.apply(this, arguments);
      }

      CoffeeScript.prototype.eval_code = function(code) {
        if (code) {
          return eval(window.CoffeeScript.compile(code, {
            bare: true
          }));
        }
      };

      CoffeeScript.prototype.language = 'coffeescript';

      return CoffeeScript;

    })(Code);
    JavaScript = (function(_super) {

      __extends(JavaScript, _super);

      function JavaScript() {
        return JavaScript.__super__.constructor.apply(this, arguments);
      }

      JavaScript.prototype.eval_code = eval_expression;

      JavaScript.prototype.language = 'javascript';

      return JavaScript;

    })(Code);
    Graph = (function(_super) {

      __extends(Graph, _super);

      function Graph() {
        Graph.__super__.constructor.apply(this, arguments);
        this.nodes = [];
        this.connections = [];
      }

      Graph.prototype.toJSON = function() {
        return _.extend(Graph.__super__.toJSON.apply(this, arguments), {
          nodes: this.nodes,
          connections: this.connections
        });
      };

      /* RUNNING
      */


      Graph.prototype.invoke = function(scope, output_nib) {
        return this.evaluate_connection(scope, this, output_nib);
      };

      Graph.prototype.evaluate_connection = function(scope, to_node, to_nib) {
        /* This helper will follow a connection and evaluate whatever it finds
        */

        var connection, connection_text, nib, node, _ref;
        connection = this.find_connection('to', to_node, to_nib);
        if (!connection) {
          connection_text = to_node.implementation != null ? to_node.implementation.text : to_node.text;
          throw new NotConnected("Missing connection in \"" + this.text + "\" to node \"" + connection_text + "\".");
        }
        _ref = connection.from, node = _ref.node, nib = _ref.nib;
        if (node === scope.lambda_node) {
          return scope.lambda_value_generators[nib.index]();
        } else if (node instanceof Graph) {
          return scope.input_value_generators[nib.index]();
        } else {
          return node.evaluate(scope, nib);
        }
      };

      Graph.prototype.find_connection = function(direction, node, nib) {
        var connection, _i, _len, _ref;
        if (!((node != null) && (nib != null))) {
          console.log("what");
          console.log("what");
        }
        /* Use this to determine how nodes are connected
        */

        _ref = this.connections;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          connection = _ref[_i];
          if (connection[direction].node.id === node.id && connection[direction].nib.id === nib.id) {
            return connection;
          }
        }
        return void 0;
      };

      Graph.prototype.delete_connections = function(direction, node, nib) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection[direction].node === node && connection[direction].nib === nib;
        });
      };

      Graph.prototype.delete_node_connections = function(node) {
        return this.connections = _.reject(this.connections, function(connection) {
          return connection.from.node === node || connection.to.node === node;
        });
      };

      Graph.prototype.delete_nodes = function(nodes) {
        this.connections = _.reject(this.connections, function(connection) {
          var _ref, _ref1;
          return (_ref = connection.from.node, __indexOf.call(nodes, _ref) >= 0) || (_ref1 = connection.to.node, __indexOf.call(nodes, _ref1) >= 0);
        });
        return this.nodes = _.without.apply(_, [this.nodes].concat(__slice.call(nodes)));
      };

      Graph.prototype["export"] = function() {
        var dependencies;
        dependencies = this.get_dependencies();
        dependencies.schema_version = schema_version;
        return dependencies;
      };

      Graph.prototype.delete_input = function(nib) {
        this.delete_connections('to', this, nib);
        return Graph.__super__.delete_input.call(this, nib);
      };

      Graph.prototype.delete_output = function(nib) {
        this.delete_connections('from', this, nib);
        return Graph.__super__.delete_output.call(this, nib);
      };

      Graph.prototype.remove_node = function(node) {
        return this.nodes = _.without(this.nodes, node);
      };

      Graph.prototype.add_node = function(node) {
        node.graph = this;
        return this.nodes.push(node);
      };

      Graph.prototype.remove_connection = function(connection) {
        return this.connections = _.without(this.connections, connection);
      };

      Graph.prototype.add_connection = function(connection) {
        return this.connections.push(connection);
      };

      Graph.prototype.uses_definition = function(definition) {
        var node, _i, _len, _ref;
        _ref = this.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          if (node.implementation === definition) {
            return true;
          }
        }
      };

      Graph.prototype.definitions_used = function() {
        var definitions, implementation, node, _i, _len, _ref;
        definitions = {};
        _ref = this.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          implementation = node.implementation;
          definitions[implementation.id] = implementation;
        }
        return definitions;
      };

      /* probably outdated
      get_dependencies: (dependencies={subroutines:{},builtins:{}}) ->
          # TODO: UPDATE
          dependencies.subroutines[@id] = @ if @id not of dependencies.subroutines
          for id, node of @nodes
              if node instanceof SubroutineApplication
                  child_dependencies = node.implementation.get_dependencies dependencies
                  _.extend dependencies.subroutines, child_dependencies.subroutines
                  _.extend dependencies.builtins, child_dependencies.builtins
              else if node instanceof BuiltinApplication
                  dependencies.builtins[@id] = node.implementation
          dependencies
      
      subroutines_referenced: ->
          # TODO: UPDATE
          # TODO: turn this into a cleanup function
          results = []
          for output in @outputs
              parent = output.get_connection()?.connection.output.parent
              if parent
                  results.push parent.id if parent.type is 'function'
                  resuts = results.concat parent.subroutines_referenced()
          return results
      
      build_adjacency_list: ->
          # clear prior data
          for id, node of @nodes
              node.adjacency_id = null
      
          adjacency_list = []
      
          # number and add self first
          adjacency_list.push
              node:@
              connections:[]
          @adjacency_id = 0
      
          # number all the connected nodes in a predictable way, and add them to the list
          input_queue = [].concat @outputs
          while input_queue.length > 0
              input = input_queue.shift()
              node = input.get_node()
              # NOTE: if node is a subroutine then we've reached ourselves again
              if node instanceof Node and node.adjacency_id is null
                  item_count = adjacency_list.push
                      node:node
                      connections:[]
                  node.adjacency_id = item_count - 1 # length is offset by 1 from index
                  input_queue = input_queue.concat node.inputs
      
          # record all the connections based on the consistent numbering scheme
          for item in adjacency_list
              nibs = if item.node instanceof Node then item.node.inputs else item.node.outputs
              for input, input_index in nibs
                  node = input.parent
                  item.connections[input_index] = node.adjacency_id
      
          adjacency_list
      */


      Graph.prototype.bust_node = function(busting_node) {
        var beginning_connection, busting_scope, connection, inbound_connections, inner_connection, inner_connections, internal_connections, middle_connection, new_node, nib, node, node_mapping, outbound_connections, outer_connection, outer_connections, through_connections, translate_endpoint, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1,
          _this = this;
        this.remove_node(busting_node);
        busting_scope = busting_node.implementation;
        node_mapping = {};
        _ref = busting_scope.nodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          node = _ref[_i];
          new_node = node.clone(this);
          node_mapping[node.id] = new_node;
        }
        translate_endpoint = function(endpoint) {
          return {
            node: node_mapping[endpoint.node.id],
            nib: endpoint.nib
          };
        };
        internal_connections = _.filter(busting_scope.connections, function(connection) {
          return connection.from.node !== busting_scope && connection.to.node !== busting_scope;
        });
        for (_j = 0, _len1 = internal_connections.length; _j < _len1; _j++) {
          connection = internal_connections[_j];
          new Connection({
            graph: this,
            from: translate_endpoint(connection.from),
            to: translate_endpoint(connection.to)
          });
        }
        inbound_connections = _.filter(this.connections, function(connection) {
          return connection.to.node === busting_node;
        });
        through_connections = [];
        for (_k = 0, _len2 = inbound_connections.length; _k < _len2; _k++) {
          connection = inbound_connections[_k];
          this.remove_connection(connection);
          nib = connection.to.nib;
          inner_connections = _.filter(busting_scope.connections, function(inner_connection) {
            return inner_connection.from.nib === nib && inner_connection.from.node === busting_scope;
          });
          for (_l = 0, _len3 = inner_connections.length; _l < _len3; _l++) {
            inner_connection = inner_connections[_l];
            if (inner_connection.to.node === busting_scope) {
              through_connections.push({
                beginning_connection: connection,
                middle_connection: inner_connection
              });
            } else {
              new Connection({
                graph: this,
                from: clone_endpoint(connection.from),
                to: translate_endpoint(inner_connection.to)
              });
            }
          }
        }
        for (_m = 0, _len4 = through_connections.length; _m < _len4; _m++) {
          _ref1 = through_connections[_m], beginning_connection = _ref1.beginning_connection, middle_connection = _ref1.middle_connection;
          nib = middle_connection.to.nib;
          outer_connections = _.filter(this.connections, function(outer_connection) {
            return outer_connection.from.nib === nib && outer_connection.from.node === busting_node;
          });
          for (_n = 0, _len5 = outer_connections.length; _n < _len5; _n++) {
            outer_connection = outer_connections[_n];
            outer_connection.from = clone_endpoint(beginning_connection.from);
          }
        }
        outbound_connections = _.filter(this.connections, function(connection) {
          return connection.from.node === busting_node;
        });
        for (_o = 0, _len6 = outbound_connections.length; _o < _len6; _o++) {
          connection = outbound_connections[_o];
          nib = connection.from.nib;
          inner_connection = _.find(busting_scope.connections, function(connection) {
            return connection.to.node === busting_scope && connection.to.nib === nib;
          });
          if (inner_connection) {
            connection.from = translate_endpoint(inner_connection.from);
          }
        }
        return _.values(node_mapping);
      };

      Graph.prototype.make_from = function(old_graph, nodes) {
        /* Build a subroutine out of nodes in another subroutine.
        */

        var connection, contained_connections, cross_threshhold, from_inside, group_connections, inbound_connections, new_node, node, outbound_connections, to_inside, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2,
          _this = this;
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          old_graph.remove_node(node);
          this.add_node(node);
        }
        new_node = new Call({
          graph: old_graph,
          position: V(0, 0),
          implementation: this
        });
        inbound_connections = [];
        outbound_connections = [];
        contained_connections = [];
        _ref = old_graph.connections;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          connection = _ref[_j];
          from_inside = (_ref1 = connection.from.node, __indexOf.call(nodes, _ref1) >= 0);
          to_inside = (_ref2 = connection.to.node, __indexOf.call(nodes, _ref2) >= 0);
          if (from_inside && to_inside) {
            contained_connections.push(connection);
          } else if (from_inside) {
            outbound_connections.push(connection);
          } else if (to_inside) {
            inbound_connections.push(connection);
          }
        }
        for (_k = 0, _len2 = contained_connections.length; _k < _len2; _k++) {
          connection = contained_connections[_k];
          old_graph.remove_connection(connection);
          this.add_connection(connection);
        }
        group_connections = function(connections) {
          var groups, key, _l, _len3, _ref3;
          groups = {};
          for (_l = 0, _len3 = connections.length; _l < _len3; _l++) {
            connection = connections[_l];
            key = "" + connection.from.nib.id + "-" + connection.from.node.id;
            if ((_ref3 = groups[key]) == null) {
              groups[key] = [];
            }
            groups[key].push(connection);
          }
          return _.values(groups);
        };
        cross_threshhold = function(connections, add_nib, direction, other_direction) {
          var data, group, new_nib, _l, _len3, _ref3, _results;
          _ref3 = group_connections(connections);
          _results = [];
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            group = _ref3[_l];
            new_nib = _this[add_nib]();
            _results.push((function() {
              var _len4, _m, _results1;
              _results1 = [];
              for (_m = 0, _len4 = group.length; _m < _len4; _m++) {
                connection = group[_m];
                data = {
                  graph: this
                };
                data[direction] = clone_endpoint(connection[direction]);
                data[other_direction] = {
                  node: this,
                  nib: new_nib
                };
                new Connection(data);
                _results1.push(connection[direction] = {
                  node: new_node,
                  nib: new_nib
                });
              }
              return _results1;
            }).call(_this));
          }
          return _results;
        };
        cross_threshhold(inbound_connections, 'add_input', 'to', 'from');
        cross_threshhold(outbound_connections, 'add_output', 'from', 'to');
        return new_node;
      };

      /*
              find_strongly_connected_components: (collected={}, index=0)->
                  @index = index
                  index += 1
                  collected[@id] = @
                  for id,definition of @definitions_used()
                      unless definition.index
                          definition.find_strongly_connected_components collected, index
                      else
      */


      return Graph;

    })(Subroutine);
    strongly_connected_components = null;
    tarjan = function() {
      var components, definition, id, index, indexed, lowlink, stack, strongconnect, _ref;
      index = 0;
      stack = [];
      indexed = {};
      lowlink = {};
      components = [];
      strongconnect = function(graph) {
        var dependency, id, new_component, node, _ref;
        indexed[graph.id] = index;
        lowlink[graph.id] = index;
        index += 1;
        stack.push(graph);
        _ref = graph.definitions_used();
        for (id in _ref) {
          dependency = _ref[id];
          if (dependency instanceof Graph) {
            if (!(dependency.id in indexed)) {
              strongconnect(dependency);
              lowlink[graph.id] = Math.min(lowlink[graph.id], lowlink[dependency.id]);
            } else if (__indexOf.call(stack, dependency) >= 0) {
              lowlink[graph.id] = Math.min(lowlink[graph.id], indexed[dependency.id]);
            }
          }
        }
        if (lowlink[graph.id] === indexed[graph.id]) {
          new_component = [];
          while (true) {
            node = stack.pop();
            new_component.push(node);
            if (node.id === graph.id) {
              if (new_component.length > 1) {
                components.push(new_component);
              }
              return;
            }
          }
        }
      };
      for (id in all_definitions) {
        definition = all_definitions[id];
        if (definition instanceof Graph) {
          if (_ref = definition.id, __indexOf.call(indexed, _ref) < 0) {
            strongconnect(definition);
          }
        }
      }
      strongly_connected_components = components;
      return components;
    };
    BoundLambda = (function() {

      function BoundLambda(_arg) {
        this.scope = _arg.scope, this.node = _arg.node;
      }

      BoundLambda.prototype.invoke = function(output_nib, inputs) {
        /*
                    Graph.evaluate_connection checks for these values in the scope,
                    which provide inputs from the calling graph to the implementing graph.
                    NOTE: it may not be possible to use a lambda within a lambda this way.
        */

        var scope;
        scope = angular.extend({}, this.scope, {
          lambda_value_generators: inputs,
          lambda_node: this.node
        });
        return this.node.graph.evaluate_connection(scope, this.node, output_nib);
      };

      return BoundLambda;

    })();
    Lambda = (function(_super) {

      __extends(Lambda, _super);

      function Lambda() {
        Lambda.__super__.constructor.apply(this, arguments);
        this.implementation_input = new Input({
          text: 'implementation',
          id: this.id
        });
      }

      Lambda.prototype.evaluate = function(scope, node) {
        /*
                    This is called on lambda values, which are kinda like subgraphs.
                    It returns a callable that is bound to the scope it was defined in,
                    not the scope it will be called in.
        */
        return new BoundLambda({
          node: node,
          scope: scope
        });
      };

      Lambda.prototype.invoke = function(parent_scope, output_nib, node) {
        var implementation, inputs;
        inputs = parent_scope.input_value_generators;
        implementation = inputs[0]();
        return implementation.invoke(output_nib, inputs.slice(1));
      };

      Lambda.prototype.get_call_inputs = function() {
        return [this.implementation_input].concat(this.inputs);
      };

      return Lambda;

    })(Graph);
    find_value = function(text, type, collection) {
      var id, thing;
      if (collection == null) {
        collection = all_definitions;
      }
      for (id in collection) {
        thing = collection[id];
        if (thing instanceof type) {
          if (!thing.text && thing.value === text) {
            return thing;
          }
        }
      }
    };
    make_value = function(graph, position, user_input, force_string) {
      var implementation, value;
      if (force_string == null) {
        force_string = false;
      }
      implementation = user_input instanceof Definition ? user_input : force_string ? (find_value(user_input, Text)) || new Text({
        value: user_input
      }) : (value = eval_expression(user_input), value instanceof String ? (find_value(value, Text)) || new Text({
        value: value
      }) : (find_value(user_input, JSON)) || new JSON({
        value: user_input
      }));
      return new Value({
        graph: graph,
        position: position,
        implementation: implementation
      });
    };
    Type = (function(_super) {

      __extends(Type, _super);

      function Type() {
        Type.__super__.constructor.apply(this, arguments);
        this.type_input = new Input({
          text: '',
          id: this.id
        });
      }

      Type.prototype.get_call_inputs = function() {
        return [this.type_input];
      };

      Type.prototype.get_value_inputs = function() {
        return this.inputs;
      };

      Type.prototype.get_call_outputs = function() {
        return this.inputs;
      };

      Type.prototype.evaluate = function(scope, nib) {
        var result, value, _i, _len, _ref, _ref1;
        result = {};
        _ref = _.zip(scope.input_value_generators, this.inputs);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], value = _ref1[0], nib = _ref1[1];
          result[nib.text] = value();
        }
        return result;
      };

      Type.prototype.invoke = function(nib, input_values, scope, node, runtime) {
        var it;
        it = input_values[0]();
        return it[nib.text];
      };

      return Type;

    })(Subroutine);
    Symbol = (function(_super) {

      __extends(Symbol, _super);

      function Symbol() {
        return Symbol.__super__.constructor.apply(this, arguments);
      }

      Symbol.prototype.evaluate = function() {
        return this.id;
      };

      Symbol.prototype.get_content_id = function() {
        return {
          type: 'symbol',
          id: this.id
        };
      };

      return Symbol;

    })(Definition);
    Literal = (function(_super) {

      __extends(Literal, _super);

      function Literal(_arg) {
        this.value = (_arg != null ? _arg : {}).value;
        Literal.__super__.constructor.apply(this, arguments);
      }

      Literal.prototype.toJSON = function() {
        return _.extend(Literal.__super__.toJSON.apply(this, arguments), {
          value: this.value
        });
      };

      Literal.prototype.get_content_id = function() {
        return {
          type: this.type,
          value: this.value
        };
      };

      return Literal;

    })(Definition);
    JSON = (function(_super) {

      __extends(JSON, _super);

      function JSON() {
        return JSON.__super__.constructor.apply(this, arguments);
      }

      JSON.prototype.type = 'json';

      JSON.prototype.evaluate = function() {
        return eval_expression(this.value);
      };

      JSON.prototype.get_content_id = function() {};

      return JSON;

    })(Literal);
    Text = (function(_super) {

      __extends(Text, _super);

      function Text() {
        return Text.__super__.constructor.apply(this, arguments);
      }

      Text.prototype.type = 'text';

      Text.prototype.evaluate = function() {
        return this.value;
      };

      Text.prototype.get_content_id = function() {
        return {
          type: 'text',
          value: this.value
        };
      };

      return Text;

    })(Literal);
    definition_classes = [Graph, JavaScript, CoffeeScript, JSON, Text, Symbol, Lambda, Type];
    definition_class_map = make_index_map(definition_classes, 'name');
    /* NODE TYPES
    */

    Node = (function(_super) {

      __extends(Node, _super);

      function Node(_arg) {
        var _ref, _ref1;
        _ref = _arg != null ? _arg : {}, this.graph = _ref.graph, this.id = _ref.id, this.position = _ref.position, this.implementation = _ref.implementation;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        this.graph.nodes.push(this);
      }

      Node.prototype.get_nib_type = function(type) {
        if (type === 'input') {
          return this.get_inputs();
        } else {
          return this.get_outputs();
        }
      };

      Node.prototype["delete"] = function() {
        this.graph.delete_node_connections(this);
        return this.graph.remove_node(this);
      };

      Node.prototype.toJSON = function() {
        return _.extend(Node.__super__.toJSON.apply(this, arguments), {
          id: this.id,
          implementation_id: this.implementation.id,
          position: this.position
        });
      };

      Node.prototype.clone = function(new_scope) {
        var data, new_node, old_id;
        data = window.JSON.parse(window.JSON.stringify(this));
        old_id = data.id;
        data.id = UUID();
        new_node = resurrect_node(new_scope, data);
        new_node.old_id = old_id;
        return new_node;
      };

      Node.prototype.virtual_inputs = function(scope) {
        var input, _i, _len, _ref, _results,
          _this = this;
        _ref = this.get_inputs();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          _results.push((function(input) {
            return function() {
              return _this.graph.evaluate_connection(scope, _this, input);
            };
          })(input));
        }
        return _results;
      };

      return Node;

    })(BaseType);
    Call = (function(_super) {

      __extends(Call, _super);

      function Call() {
        return Call.__super__.constructor.apply(this, arguments);
      }

      Call.prototype.evaluate = function(parent_scope, output_nib) {
        var child_scope, scope;
        scope = parent_scope.nodes[this.id];
        if (scope == null) {
          child_scope = {};
          scope = parent_scope.nodes[this.id] = {
            runtime: parent_scope.runtime,
            parent_scope: parent_scope,
            nodes: child_scope,
            state: child_scope,
            output_values: {}
          };
          scope.input_value_generators = this.virtual_inputs(parent_scope);
        }
        if (!(output_nib.id in scope.output_values)) {
          scope.output_values[output_nib.id] = this.implementation.invoke(scope, output_nib, this);
        }
        return scope.output_values[output_nib.id];
      };

      Call.prototype.get_inputs = function() {
        return this.implementation.get_call_inputs();
      };

      Call.prototype.get_outputs = function() {
        return this.implementation.get_call_outputs();
      };

      /*
              subroutines_referenced: ->
                  # TODO: UPDATE
                  return [] unless @implementation instanceof Graph
                  results = []
                  for input in @inputs
                      parent = input.get_connection()?.connection.output.parent
                      if parent
                          results.push parent.id if parent.type is 'function'
                          resuts = results.concat parent.subroutines_referenced()
                  return results
      */


      return Call;

    })(Node);
    Value = (function(_super) {

      __extends(Value, _super);

      function Value() {
        Value.__super__.constructor.apply(this, arguments);
        this.outputs = [value_output_nib];
      }

      Value.prototype.type = 'value';

      Value.prototype.evaluate = function(parent_scope, output_nib) {
        return this.implementation.evaluate(parent_scope, this);
      };

      Value.prototype.subroutines_referenced = function() {
        return [];
      };

      Value.prototype.get_inputs = function() {
        return this.implementation.get_value_inputs();
      };

      Value.prototype.get_outputs = function() {
        return this.outputs;
      };

      return Value;

    })(Node);
    UnknownNode = (function(_super) {

      __extends(UnknownNode, _super);

      function UnknownNode(position, type, text, id) {
        this.position = position;
        this.id = id;
        this.type = 'unknown';
        this.text = "Unknown " + type + ": " + text;
        this.inputs = [];
        this.outputs = [];
        UnknownNode.__super__.constructor.apply(this, arguments);
      }

      return UnknownNode;

    })(Node);
    node_classes = [Call, Value];
    node_class_map = make_index_map(node_classes, 'name');
    /* OTHER TYPES
    */

    Nib = (function() {

      function Nib(_arg) {
        var _ref, _ref1, _ref2;
        _ref = _arg != null ? _arg : {}, this.text = _ref.text, this.id = _ref.id, this.index = _ref.index, this.n_ary = _ref.n_ary, this.default_value = _ref.default_value;
        if (this.id !== null) {
          if ((_ref1 = this.id) == null) {
            this.id = UUID();
          }
        }
        if ((_ref2 = this.n_ary) == null) {
          this.n_ary = false;
        }
      }

      Nib.prototype.initialize = function() {
        return this;
      };

      Nib.prototype.toJSON = function() {
        return {
          text: this.text,
          id: this.id,
          n_ary: this.n_ary,
          default_value: this.default_value
        };
      };

      return Nib;

    })();
    Input = (function(_super) {

      __extends(Input, _super);

      function Input() {
        return Input.__super__.constructor.apply(this, arguments);
      }

      return Input;

    })(Nib);
    Output = (function(_super) {

      __extends(Output, _super);

      function Output() {
        return Output.__super__.constructor.apply(this, arguments);
      }

      return Output;

    })(Nib);
    Connection = (function() {

      function Connection(_arg) {
        var _base, _base1, _ref, _ref1, _ref2, _ref3;
        _ref = _arg != null ? _arg : {}, this.graph = _ref.graph, this.from = _ref.from, this.to = _ref.to, this.id = _ref.id;
        if ((_ref1 = this.id) == null) {
          this.id = UUID();
        }
        this.graph.connections.push(this);
        if ((_ref2 = (_base = this.to).index) == null) {
          _base.index = 0;
        }
        if ((_ref3 = (_base1 = this.from).index) == null) {
          _base1.index = 0;
        }
        if (!(this.from instanceof Object && this.to instanceof Object)) {
          throw "WTF";
        }
      }

      Connection.prototype.toJSON = function() {
        return {
          from: {
            nib: this.from.nib.id,
            node: this.from.node.id,
            index: this.from.node.index,
            internal: this.from.internal
          },
          to: {
            nib: this.to.nib.id,
            node: this.to.node.id,
            index: this.to.node.index,
            internal: this.to.internal
          }
        };
      };

      return Connection;

    })();
    value_output_nib = new Output({
      id: 'value_output',
      index: 0
    });
    sequencer_input_nib = new Input({
      id: 'sequencer_input',
      index: 0,
      text: ';'
    });
    sequencer_output_nib = new Output({
      id: 'sequencer_output',
      index: 0,
      text: ';'
    });
    is_input = function(it) {
      var is_input_class;
      is_input_class = it.nib instanceof Input;
      if (it.node instanceof Graph || (it.node instanceof Call && it.node.implementation instanceof Type) || it.internal) {
        return is_input_class;
      } else {
        return !is_input_class;
      }
    };
    make_connection = function(graph, _arg) {
      var connector, from, from_input, to, to_input, _i, _len, _ref, _ref1;
      from = _arg.from, to = _arg.to;
      _ref = [to, from];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        connector = _ref[_i];
        if (connector.node.implementation instanceof Lambda && connector.node instanceof Value && connector.nib !== value_output_nib) {
          connector.internal = true;
        }
      }
      from_input = is_input(from);
      to_input = is_input(to);
      if (!((from_input && !to_input) || (to_input && !from_input))) {
        return;
      }
      if (to_input) {
        _ref1 = [to, from], from = _ref1[0], to = _ref1[1];
      }
      graph.delete_connections('to', to.node, to.nib);
      return new Connection({
        graph: graph,
        from: from,
        to: to
      });
    };
    find_nib_uses = function(nib, direction) {
      var connection, id, subroutine, uses, _i, _len, _ref;
      if (direction == null) {
        direction = 'to';
      }
      uses = {};
      for (id in all_definitions) {
        subroutine = all_definitions[id];
        if (!(subroutine instanceof Graph)) {
          continue;
        }
        _ref = subroutine.connections;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          connection = _ref[_i];
          if (connection[direction].nib === nib) {
            uses[subroutine.id] = subroutine;
          }
        }
      }
      return uses;
    };
    dissociate_exception = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        return $timeout(function() {
          throw exception;
        });
      }
    };
    execute = function(runtime, routine) {
      try {
        return runtime.log(window.JSON.stringify(routine()));
      } catch (exception) {
        if (exception instanceof RuntimeException) {
          return runtime.log("Error: " + exception.message);
        } else {
          throw exception;
        }
      }
    };
    ignore_if_disconnected = function(procedure) {
      try {
        return procedure();
      } catch (exception) {
        if (!(exception instanceof NotConnected)) {
          throw exception;
        }
      }
    };
    start_saving = function() {
      return setInterval(save_state, 500);
    };
    save_state = function() {
      var state;
      state = {
        definitions: _.values(all_definitions),
        schema_version: schema_version
      };
      return localStorage.state = window.JSON.stringify(state);
    };
    load_state = function(data) {
      var builtin, builtin_data, definition_data, graph, id, implementation_pass, instance, second_pass, subroutine, subroutine_data, subroutines, the_class, transform_definition_data, transform_nib_data, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      switch (data.schema_version) {
        case 1:
          subroutines = {};
          second_pass = [];
          transform_nib_data = function(nib_texts) {
            var index, text, _i, _len, _results;
            _results = [];
            for (index = _i = 0, _len = nib_texts.length; _i < _len; index = ++_i) {
              text = nib_texts[index];
              _results.push({
                text: text,
                index: index
              });
            }
            return _results;
          };
          transform_definition_data = function(definition_data) {
            definition_data.inputs = transform_nib_data(definition_data.inputs);
            definition_data.outputs = transform_nib_data(definition_data.outputs);
            return definition_data.text = definition_data.name;
          };
          _ref = data.builtins;
          for (id in _ref) {
            builtin_data = _ref[id];
            transform_definition_data(builtin_data);
            builtin = new JavaScript(builtin_data);
            subroutines[builtin.id] = builtin;
          }
          _ref1 = data.subroutines;
          for (id in _ref1) {
            subroutine_data = _ref1[id];
            transform_definition_data(subroutine_data);
            subroutine_data.text = subroutine_data.name;
            subroutine = new Graph(subroutine_data);
            subroutines[subroutine.id] = subroutine;
            second_pass.push(subroutine);
          }
          for (_i = 0, _len = second_pass.length; _i < _len; _i++) {
            subroutine = second_pass[_i];
            load_implementation(subroutine, data.subroutines[subroutine.id], subroutines);
          }
          return all_definitions;
        case 2:
          implementation_pass = [];
          _ref2 = data.definitions;
          for (id in _ref2) {
            definition_data = _ref2[id];
            if (definition_data.type === 'JSONLiteral') {
              definition_data.type = 'JSON';
            } else if (definition_data.type === 'StringLiteral') {
              definition_data.type = 'Text';
            }
            if ((_ref3 = definition_data.type) === 'JSON' || _ref3 === 'Text') {
              if ((_ref4 = definition_data.value) == null) {
                definition_data.value = definition_data.text;
              }
              if (definition_data.value === definition_data.text) {
                delete definition_data.text;
              }
            }
            the_class = definition_class_map[definition_data.type];
            instance = new the_class(definition_data);
            if (instance instanceof Graph) {
              implementation_pass.push({
                graph: instance,
                data: definition_data
              });
            }
          }
          for (_j = 0, _len1 = implementation_pass.length; _j < _len1; _j++) {
            _ref5 = implementation_pass[_j], graph = _ref5.graph, data = _ref5.data;
            load_implementation_v2(graph, data);
          }
          return all_definitions;
      }
    };
    resurrect_node = function(graph, node_data) {
      var implementation, node, node_class, position;
      node_class = node_class_map[node_data.type];
      position = V(node_data.position);
      implementation = all_definitions[node_data.implementation_id];
      return node = new node_class({
        graph: graph,
        position: position,
        implementation: implementation,
        id: node_data.id
      });
    };
    load_implementation_v2 = function(graph, data) {
      var connection_data, from_nib, from_node, get_nib, get_node, node_data, to_nib, to_node, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node_data = _ref[_i];
        resurrect_node(graph, node_data);
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection_data = _ref1[_j];
        get_node = function(direction) {
          var id;
          id = connection_data[direction].node;
          if (id === graph.id) {
            return graph;
          } else {
            return _.find(graph.nodes, function(node) {
              return node.id === id;
            });
          }
        };
        from_node = get_node('from');
        to_node = get_node('to');
        get_nib = function(node, connector, nib_type) {
          var nibs;
          if (connector.internal) {
            nibs = node.implementation["get_" + nib_type]();
            return _.find(nibs, function(nib) {
              return nib.id === connector.nib;
            });
          } else {
            nibs = node["get_" + nib_type]();
            return _.find(nibs, function(nib) {
              return nib.id === connector.nib || (nib.id === 'value_output' && connector.nib === null);
            });
          }
        };
        from_nib = get_nib(from_node, connection_data['from'], 'outputs');
        to_nib = get_nib(to_node, connection_data['to'], 'inputs');
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          graph: graph,
          from: {
            node: from_node,
            nib: from_nib,
            internal: connection_data.from.internal
          },
          to: {
            node: to_node,
            nib: to_nib,
            internal: connection_data.to.internal
          }
        }));
      }
      return _results;
    };
    load_implementation = function(subroutine, data, subroutines) {
      var connection_data, found_value, from_nib, from_node, get_node, implementation, node, position, to_nib, to_node, value, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = data.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        position = V(node.position);
        if (node.type === 'literal') {
          implementation = 'implementation_id' in node ? subroutines[node.implementation_id] : (found_value = find_value(node.text, JSON, subroutines), found_value ? found_value : (value = new JSON({
            text: node.text
          }), subroutines[value.id] = value, value));
          new Value({
            graph: subroutine,
            position: position,
            implementation: implementation,
            id: node.id
          });
        } else {
          implementation = subroutines[node.implementation_id];
          if (implementation) {
            new Call({
              graph: subroutine,
              position: position,
              implementation: implementation,
              id: node.id
            });
          } else {
            new UnknownNode(position, node.type, node.text, node.id);
          }
        }
      }
      _ref1 = data.connections;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        connection_data = _ref1[_j];
        get_node = function(nib) {
          if (nib.parent_id === subroutine.id) {
            return subroutine;
          } else {
            return _.find(subroutine.nodes, function(node) {
              return node.id === nib.parent_id;
            });
          }
        };
        from_node = get_node(connection_data.output);
        to_node = get_node(connection_data.input);
        from_nib = from_node.get_outputs()[connection_data.output.index];
        to_nib = to_node.get_inputs()[connection_data.input.index];
        if (!(from_node && to_node && from_nib && to_nib)) {
          console.log("Broken connection!", connection_data, from_node, to_node, from_nib, to_nib);
        }
        _results.push(new Connection({
          id: connection_data.id,
          graph: subroutine,
          from: {
            node: from_node,
            nib: from_nib
          },
          to: {
            node: to_node,
            nib: to_nib
          }
        }));
      }
      return _results;
    };
    if (localStorage.state != null) {
      source_data = window.JSON.parse(localStorage.state);
    } else {
      source_data_deferred = $q.defer();
      source_data = source_data_deferred.promise;
      $http.get('examples.json').success(function(data) {
        return source_data_deferred.resolve(data);
      });
    }
    all_definitions = {};
    loaded = $q.defer();
    $q.when(source_data, function(source_data) {
      var id, obj, _ref;
      _ref = load_state(source_data);
      for (id in _ref) {
        obj = _ref[id];
        all_definitions[id] = obj;
      }
      loaded.resolve(true);
      console.log(tarjan());
      if (window.location.search !== '?debug') {
        return start_saving();
      }
    });
    return {
      make_connection: make_connection,
      find_nib_uses: find_nib_uses,
      make_value: make_value,
      loaded: loaded.promise,
      tarjan: tarjan,
      RuntimeException: RuntimeException,
      Exit: Exit,
      InputError: InputError,
      NotConnected: NotConnected,
      NotImplemented: NotImplemented,
      BuiltinSyntaxError: CodeSyntaxError,
      definition_types: definition_classes,
      Definition: Definition,
      Subroutine: Subroutine,
      Graph: Graph,
      Code: Code,
      JavaScript: JavaScript,
      CoffeeScript: CoffeeScript,
      Lambda: Lambda,
      Type: Type,
      Literal: Literal,
      JSON: JSON,
      Text: Text,
      Symbol: Symbol,
      Node: Node,
      Call: Call,
      Value: Value,
      Input: Input,
      Output: Output,
      Connection: Connection,
      subroutines: all_definitions,
      Runtime: Runtime
    };
  });

}).call(this);
