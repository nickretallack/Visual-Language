// Generated by CoffeeScript 1.3.1
var NodeView, all_builtins, all_subroutines, animate, animations_counter, blab, boxes, connecting_object, connection_view, current_scope, dissociate_exception, dragging_object, dragging_offset, editor_size, eval_expression, execute, get_absolute_nib_position, get_nib_position, highlight, highlighted_objects, ignore_if_disconnected, last, make_arrow, make_box, make_connection, make_nib_view, make_node_view, make_subroutine_view, make_text, module, mouse_coords, node_registry, obj_first, pretty_json, ray_cast_mouse, schema_version, should_animate, system_arrow, unhighlight, unhighlight_all, update, valid_json, whitespace_split;

editor_size = V(window.innerWidth, window.innerHeight);

V(1, 1).plus(V(2, 2));

module = angular.module('vislang', []);

module.directive('io', function() {
  return function(scope, element, attributes) {
    return scope.$watch(attributes.io, function(node) {
      var pair, _i, _len, _ref, _ref1, _ref2, _results;
      element.html('');
      _ref = _.zip(node.inputs, node.outputs);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pair = _ref[_i];
        _results.push(element.append($("<tr>\n    <td class=\"input\">" + (((_ref1 = pair[0]) != null ? _ref1.text : void 0) || '') + "</td>\n    <td class=\"output\">" + (((_ref2 = pair[1]) != null ? _ref2.text : void 0) || '') + "</td>\n</tr>")));
      }
      return _results;
    });
  };
});

module.directive('subroutine', function() {
  return {
    link: function(scope, element, attributes) {},
    controller: function($scope, $element) {
      var $$element;
      $$element = $($element);
      $scope.editor_size = V($$element.width(), $$element.height());
      return $scope.position = function(node) {
        var position;
        position = node.position.plus($scope.editor_size.scale(0.5));
        return {
          left: (position.y - 250 + $scope.editor_size.x / 2) + 'px',
          top: (position.x - 700 + $scope.editor_size.y / 2) + 'px'
        };
      };
    }
  };
});

module.config(function($routeProvider) {
  return $routeProvider.when('/:id', {
    controller: 'subroutine',
    template: "subroutine.html"
  });
});

module.controller('subroutine', function($scope, $routeParams, subroutines, $q) {
  return $q.when(subroutines, function(subroutines) {
    $scope.current_object = subroutines[$routeParams.id];
    return console.log($scope.current_object, $routeParams.id, subroutines);
  });
});

module.controller('library', function($scope, subroutines, $q) {
  return $scope.subroutines = subroutines;
});

/*
<ul class="inputs"><li ng-repeat="input in node.inputs">{{input.text}}</li></ul>
<ul class="outputs"><li ng-repeat="output in node.outputs">{{output.text}}</li></ul>


module.directive 'subroutine', ->
    (scope, element, attributes) ->
        graphics = Raphael element[0], editor_size.components()...
        scope.$watch attributes.subroutine, (subroutine) ->
            graphics.clear()
            for id, node of subroutine.nodes
                new NodeView graphics, node
*/


blab = function() {
  return console.log(arguments);
};

NodeView = (function() {

  NodeView.name = 'NodeView';

  function NodeView(graphics, node) {
    var corner_position, editor_offset, position, size, text_width;
    this.graphics = graphics;
    this.node = node;
    this.set = graphics.set();
    size = V(50, 50);
    editor_offset = editor_size.scale(0.5);
    position = V(node.position).plus(editor_offset);
    position.y = editor_size.y - position.y;
    this.text = graphics.text(position.x, position.y + 10, node.text);
    this.text.attr('text-anchor', 'middle');
    this.set.push(this.text);
    text_width = this.text.getBBox().width;
    corner_position = position.minus(V(text_width / 2, 0));
    this.shape = graphics.rect(corner_position.x - 5, corner_position.y, text_width + 10, size.y);
    this.shape.attr('fill', 'blue');
    this.set.push(this.shape);
    this.shape.drag(blab, blab, blab);
  }

  return NodeView;

})();

last = function(list) {
  return list[list.length - 1];
};

obj_first = function(obj) {
  var item, key;
  for (key in obj) {
    item = obj[key];
    return item;
  }
};

schema_version = 1;

boxes = {};

node_registry = {};

all_subroutines = {};

all_builtins = {};

current_scope = null;

system_arrow = null;

should_animate = false;

update = function() {
  return renderer.render(scene, camera);
};

animations_counter = 0;

animate = function(field) {
  requestAnimationFrame((function() {
    return animate(field);
  }), field);
  animations_counter += 1;
  return update();
};

eval_expression = function(expression) {
  return eval("(" + expression + ")");
};

setInterval(function() {
  return animations_counter = 0;
}, 1000);

/* VIEWS
*/


make_subroutine_view = function(subroutine) {};

/*
    box_size = editor_size
    position = box_size.scale(1/2.0)
    box = make_box null, subroutine_mesh, 10, position
    box.model = subroutine
    boxes[box.id] = box
    return box
*/


make_node_view = function(node) {};

/*
    main_box = make_box node.text, node_mesh, 10, node.position
    main_box.model = node
    node.scope.view.add main_box
    boxes[main_box.id] = main_box
    return main_box
*/


make_nib_view = function(nib, is_node) {};

/*
    parent_size = if is_node then V(60,60) else editor_size.minus V 10,10

    y_offset = parent_size.y / 2.0

    x_position = -parent_size.x / 2.0 + parent_size.x * nib.index/nib.siblings
    y_position = y_offset * (if nib instanceof Input then 1 else -1) * (if is_node then 1 else -1)

    sub_box = make_box nib.text, nib_mesh, 5, V(x_position,y_position)
    sub_box.model = nib

    parent = nib.parent.view
    parent.add sub_box
    return sub_box
*/


connection_view = function(connection) {};

/*
    point1 = get_nib_position connection.input
    point2 = get_nib_position connection.output
    arrow = make_arrow point1, point2
    [arrow, arrow.geometry.vertices[0], arrow.geometry.vertices[1]]
*/


/* FACTORIES
*/


make_connection = function(source, target) {
  var input, output;
  if (source.model instanceof Input) {
    input = source.model;
    output = target.model;
  } else {
    input = target.model;
    output = source.model;
  }
  return new Connection(input, output);
};

/* CORE RENDERING
*/


make_text = function(text, size) {
  var centerOffset, geometry, material, mesh;
  geometry = new THREE.TextGeometry(text, {
    size: size,
    font: 'helvetiker',
    curveSegments: 2
  });
  geometry.computeBoundingBox();
  centerOffset = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
  material = new THREE.MeshBasicMaterial({
    color: 0x000000,
    overdraw: true
  });
  mesh = new THREE.Mesh(geometry, material);
  mesh.position.x = centerOffset;
  return mesh;
};

/*
node_material = new THREE.MeshBasicMaterial color:0x888888
highlighted_node_material = new THREE.MeshBasicMaterial color:0x8888FF
subroutine_material = new THREE.MeshBasicMaterial color:0xEEEEEE

node_geometry = new THREE.PlaneGeometry 50,50
nib_geometry = new THREE.PlaneGeometry 20,20
subroutine_geometry = new THREE.PlaneGeometry editor_size.x,editor_size.y

node_mesh = [node_geometry, node_material]
nib_mesh = [nib_geometry, node_material]
subroutine_mesh = [subroutine_geometry, subroutine_material]
*/


make_box = function(name, mesh, text_size, position) {
  var box;
  box = new THREE.Object3D();
  box.add((function(func, args, ctor) {
    ctor.prototype = func.prototype;
    var child = new ctor, result = func.apply(child, args), t = typeof result;
    return t == "object" || t == "function" ? result || child : child;
  })(THREE.Mesh, mesh, function(){}));
  if (name) {
    box.add(make_text(name, text_size));
  }
  box.position = position.three();
  return box;
};

make_arrow = function(source, target, scoped) {
  var arrow, color, line, line_geometry, line_material;
  if (scoped == null) {
    scoped = true;
  }
  arrow = new THREE.Object3D();
  color = 0x888888;
  if ('three' in source) {
    source = source.three();
  }
  if ('three' in target) {
    target = target.three();
  }
  line_geometry = new THREE.Geometry();
  line_material = new THREE.LineBasicMaterial({
    color: color,
    linewidth: 3
  });
  line_geometry.vertices.push(new THREE.Vertex(source));
  line_geometry.vertices.push(new THREE.Vertex(target));
  line = new THREE.Line(line_geometry, line_material);
  if (scoped) {
    current_scope.view.add(line);
  }
  return line;
};

/* CORE HELPERS
*/


ray_cast_mouse = function() {
  var forward, intersections, mouse, ray;
  mouse = mouse_coords(event).three();
  mouse.z = 1;
  forward = new THREE.Vector3(0, 0, -1);
  ray = new THREE.Ray(mouse, forward);
  intersections = ray.intersectScene(scene);
  if (intersections.length > 0) {
    return (last(intersections)).object.parent;
  }
};

mouse_coords = function(event) {
  return V(event.offsetX, editor_size.y - event.offsetY);
};

get_nib_position = function(nib) {
  if (nib.parent instanceof Node) {
    return Vector.from(nib.view.position).plus(nib.view.parent.position).three();
  } else {
    return Vector.from(nib.view.position).three();
  }
};

get_absolute_nib_position = function(nib) {
  return Vector.from(get_nib_position(nib)).plus(half_editor_size).three();
};

/* INTERACTION
*/


dragging_object = null;

connecting_object = null;

dragging_offset = V(0, 0);

highlighted_objects = {};

highlight = function(node) {
  node.view.children[0].material = highlighted_node_material;
  return highlighted_objects[node.id] = node;
};

unhighlight = function(node) {
  node.view.children[0].material = node_material;
  return delete highlighted_objects[node.id];
};

unhighlight_all = function() {
  var id, obj, _results;
  _results = [];
  for (id in highlighted_objects) {
    obj = highlighted_objects[id];
    _results.push(unhighlight(obj));
  }
  return _results;
};

whitespace_split = function(input) {
  var results;
  results = input.split(/\s+/);
  if (results[0] === '') {
    results = results.slice(1);
  }
  return results;
};

valid_json = function(json) {
  try {
    return JSON.parse(json);
  } catch (exception) {
    if (exception instanceof SyntaxError) {
      alert("" + exception + " Invalid JSON: " + json);
      return false;
    } else {
      throw exception;
    }
  }
};

pretty_json = function(obj) {
  return JSON.stringify(obj, void 0, 2);
};

module.controller('Controller', function($scope, $http, $location) {
  var import_data, run_native_routine, run_subroutine, save_state, saving, start_saving,
    _this = this;
  $scope.overlay = null;
  $scope.tab_click = function(tab) {
    return $scope.overlay = $scope.overlay === tab ? null : tab;
  };
  /*
      init_field = ->
          if not should_animate
              field = $("#field")
              field.append renderer.domElement
              should_animate = true
              animate field[0]
              field.mousedown mouse_down
              field.mouseup mouse_up
              field.mousemove mouse_move
              field.bind 'contextmenu', -> false
  
      teardown_field = ->
          should_animate = false
  
      mouse_down = (event) =>
          event.preventDefault()
          target = ray_cast_mouse()
          if target
              if target.model instanceof Node
                  if event.which is 3
                      target.model.delete()
                  else if event.shiftKey
                      highlight target.model
                  else if event.ctrlKey
                      $scope.edit target.model.implementation
                      $scope.$digest()
                  else
                      dragging_object = target
              else if target.model instanceof Nib
                  if event.which is 3
                      target.model.delete_connections()
                  else
                      system_arrow.geometry.vertices[0].position = system_arrow.geometry.vertices[1].position = get_absolute_nib_position target.model
                      scene.add system_arrow
                      connecting_object = target
              else
                  unless event.shiftKey
                      unhighlight_all()
  
      mouse_up = (event) =>
          dragging_object = null
  
          if connecting_object
              target = ray_cast_mouse()
              if target?.model instanceof Nib
                  connection = make_connection connecting_object, target
              connecting_object = null
              scene.remove system_arrow
  
      mouse_move = (event) =>
          mouse_vector = mouse_coords(event)
          adjusted_vector = mouse_vector.minus(half_editor_size)
          vector = mouse_vector.three()
          if dragging_object
              node = dragging_object.model
              original_position = Vector.from node.view.position
              delta = adjusted_vector.minus original_position
  
              effected_nodes = if node.id of highlighted_objects then _.values highlighted_objects else [node]
  
              for node in effected_nodes
                  node.set_position Vector.from(node.position).plus(delta).three()
                  for nib in node.get_nibs()
                      for id, connection of nib.connections
                          connection.vertex.position.copy get_nib_position nib
  
          if connecting_object
              system_arrow.geometry.vertices[1].position = vector
  */

  saving = false;
  start_saving = function() {};
  $scope.log = function(expression) {
    return console.log(expression);
  };
  $scope.import_export_text = '';
  $scope.subroutines = {};
  $scope.builtins = {};
  $scope["import"] = function() {
    import_data(valid_source($scope.import_export_text));
    if (current_scope) {
      $scope.edit(current_scope);
    }
    return start_saving();
  };
  import_data = function(source_data) {
    var builtin, data, id, subroutine, _ref, _ref1, _results;
    data = load_state(source_data);
    _ref = data.subroutines;
    for (id in _ref) {
      subroutine = _ref[id];
      $scope.subroutines[subroutine.id] = subroutine;
    }
    _ref1 = data.builtins;
    _results = [];
    for (id in _ref1) {
      builtin = _ref1[id];
      _results.push($scope.builtins[builtin.id] = builtin);
    }
    return _results;
  };
  $scope.export_all = function() {
    var data;
    data = {
      subroutines: $scope.subroutines,
      builtins: $scope.builtins,
      schema_version: schema_version
    };
    return $scope.import_export_text = pretty_json(data);
  };
  $scope.export_subroutine = function(subroutine) {
    return $scope.import_export_text = pretty_json(subroutine["export"]());
  };
  $scope.export_builtin = function(builtin) {
    return $scope.import_export_text = pretty_json(builtin["export"]());
  };
  $scope.revert = function() {
    $scope.subroutines = {};
    $scope.builtins = {};
    return $scope.load_example_programs();
  };
  $scope.literal_text = '';
  $scope.use_literal = function() {
    if (valid_json($scope.literal_text)) {
      new Literal(V(0, 0), $scope.literal_text);
      return $scope.literal_text = '';
    }
  };
  $scope.use_builtin = function(builtin) {
    return new BuiltinApplication(V(0, 0), builtin);
  };
  $scope.use_subroutine = function(subroutine) {
    return new SubroutineApplication(V(0, 0), subroutine);
  };
  $scope.use_subroutine_value = function(subroutine) {
    return new Literal(V(0, 0), subroutine);
  };
  $scope.initial_subroutine = {
    name: '',
    inputs: [],
    outputs: []
  };
  $scope.new_subroutine = angular.copy($scope.initial_subroutine);
  $scope.delete_subroutine = function(subroutine) {
    if (subroutine.id === current_scope.id) {
      $scope.current_object = null;
      teardown_field();
    }
    return delete $scope.subroutines[subroutine.id];
  };
  $scope.delete_builtin = function(builtin) {
    return delete $scope.builtins[builtin.id];
  };
  $scope.add_subroutine = function() {
    var connection, contained_connections, id, in_connections, nib, node, out_connections, subroutine, _ref, _ref1, _ref2, _ref3;
    subroutine = new SubRoutine($scope.new_subroutine.name, $scope.new_subroutine.inputs, $scope.new_subroutine.outputs);
    in_connections = {};
    out_connections = {};
    for (id in highlighted_objects) {
      node = highlighted_objects[id];
      _ref = node.inputs;
      for (id in _ref) {
        nib = _ref[id];
        _ref1 = nib.connections;
        for (id in _ref1) {
          connection = _ref1[id];
          in_connections[connection.connection.id] = connection.connection;
        }
      }
      _ref2 = node.outputs;
      for (id in _ref2) {
        nib = _ref2[id];
        _ref3 = nib.connections;
        for (id in _ref3) {
          connection = _ref3[id];
          out_connections[connection.connection.id] = connection.connection;
        }
      }
    }
    contained_connections = {};
    for (id in in_connections) {
      connection = in_connections[id];
      if (connection.id in out_connections) {
        contained_connections[connection.id] = connection;
        delete in_connections[connection.id];
        delete out_connections[connection.id];
      }
    }
    for (id in contained_connections) {
      connection = contained_connections[id];
      current_scope.remove_connection(connection);
      subroutine.add_connection(connection);
    }
    for (id in in_connections) {
      connection = in_connections[id];
      connection["delete"]();
    }
    for (id in out_connections) {
      connection = out_connections[id];
      connection["delete"]();
    }
    for (id in highlighted_objects) {
      node = highlighted_objects[id];
      current_scope.remove_node(node);
      subroutine.add_node(node);
    }
    $scope.subroutines[subroutine.id] = subroutine;
    $scope.new_subroutine = angular.copy($scope.initial_subroutine);
    $scope.new_subroutine.inputs = [];
    $scope.new_subroutine.outputs = [];
    return $scope.edit(subroutine);
  };
  $scope.add_builtin = function() {
    var builtin;
    builtin = new Builtin({});
    $scope.builtins[builtin.id] = builtin;
    return $scope.edit(builtin);
  };
  $scope.run_subroutine = function(subroutine, output_index) {
    if (subroutine instanceof SubRoutine) {
      return run_subroutine(subroutine, output_index);
    } else {
      return run_native_routine(subroutine, output_index);
    }
  };
  run_subroutine = function(subroutine, output_index) {
    var input, input_index, input_values, _fn, _i, _len, _ref;
    input_values = [];
    _ref = subroutine.inputs;
    _fn = function(input_index, input) {
      var value;
      value = _.memoize(function() {
        var result;
        result = prompt("Provide a JSON value for input " + input_index + ": \"" + input.text + "\"");
        if (result === null) {
          throw new Exit("cancelled execution");
        }
        try {
          return JSON.parse(result);
        } catch (exception) {
          if (exception instanceof SyntaxError) {
            throw new InputError(result);
          } else {
            throw exception;
          }
        }
      });
      return input_values.push(value);
    };
    for (input_index = _i = 0, _len = _ref.length; _i < _len; input_index = ++_i) {
      input = _ref[input_index];
      _fn(input_index, input);
    }
    try {
      return setTimeout(subroutine.run(output_index, input_values));
    } catch (exception) {
      if (exception instanceof InputError) {
        return alert("Invalid JSON: " + exception.message);
      } else {
        throw exception;
      }
    }
  };
  run_native_routine = function(builtin, output_index) {
    var _this = this;
    return execute(function() {
      var args, input, input_index, input_values, memo, memo_function, output_function, the_scope, _fn, _i, _len, _ref;
      input_values = [];
      _ref = builtin.inputs;
      _fn = function(input_index, input) {
        return input_values.push(function() {
          return valid_json(prompt("Provide a JSON value for input " + input_index + ": \"" + input + "\""));
        });
      };
      for (input_index = _i = 0, _len = _ref.length; _i < _len; input_index = ++_i) {
        input = _ref[input_index];
        _fn(input_index, input);
      }
      the_scope = {
        memos: {}
      };
      try {
        memo_function = eval_expression(builtin.memo_implementation);
        output_function = eval_expression(builtin.output_implementation);
      } catch (exception) {
        if (exception instanceof SyntaxError) {
          throw new BuiltinSyntaxError(builtin.text, exception);
        } else {
          throw exception;
        }
      }
      if (!output_function) {
        throw new NotImplemented(builtin.text);
      }
      args = input_values.concat([output_index]);
      if (memo_function) {
        memo = memo_function.apply(null, args);
      }
      return output_function.apply(null, args.concat([memo]));
    });
  };
  return save_state = function() {
    var state;
    state = {
      subroutines: $scope.subroutines,
      builtins: $scope.builtins,
      schema_version: schema_version
    };
    return localStorage.state = JSON.stringify(state);
  };
});

module.factory('subroutines', function($q, $http) {
  var source_data;
  if (localStorage.state != null) {
    source_data = localStorage.state;
  } else {
    source_data = $q.defer();
    $http.get('examples.json').success(function(data) {
      return source_data.resolve(data);
    });
  }
  return $q.when(source_data.promise, function(source_data) {
    var data, subroutines;
    data = load_state(source_data);
    subroutines = $.extend(data.builtins, data.subroutines);
    return subroutines;
  });
});

dissociate_exception = function(procedure) {
  try {
    return procedure();
  } catch (exception) {
    return setTimeout(function() {
      throw exception;
    });
  }
};

execute = function(routine) {
  try {
    return alert(JSON.stringify(routine()));
  } catch (exception) {
    if (exception instanceof RuntimeException) {
      return alert("Error: " + exception.message);
    } else {
      throw exception;
    }
  }
};

ignore_if_disconnected = function(procedure) {
  try {
    return procedure();
  } catch (exception) {
    if (!(exception instanceof NotConnected)) {
      throw exception;
    }
  }
};
